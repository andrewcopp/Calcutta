package simulated_calcutta

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"
)

type calcuttaContext struct {
	CalcuttaID   string
	TournamentID string
}

func (s *Service) getLatestTournamentSimulationBatchID(ctx context.Context, bronzeTournamentID string, coreTournamentID string) (string, bool, error) {
	var batchID string
	err := s.pool.QueryRow(ctx, `
		SELECT b.id
		FROM derived.simulated_tournaments b
		WHERE b.tournament_id = $2
			AND b.deleted_at IS NULL
			AND EXISTS (
				SELECT 1
				FROM derived.simulated_teams st
				WHERE st.tournament_id = $1
					AND st.simulated_tournament_id = b.id
					AND st.deleted_at IS NULL
			)
		ORDER BY b.created_at DESC
		LIMIT 1
	`, bronzeTournamentID, coreTournamentID).Scan(&batchID)
	if err != nil {
		if err == pgx.ErrNoRows {
			return "", false, nil
		}
		return "", false, err
	}
	return batchID, true, nil
}

func (s *Service) getCalcuttaContext(ctx context.Context, bronzeTournamentID string) (*calcuttaContext, error) {
	// Resolve a single calcutta_id (and its tournament_id) for a given bronze tournament.
	// This intentionally isolates the season/name join in one place.
	query := `
		SELECT c.id, c.tournament_id
		FROM derived.tournaments bt
		JOIN core.tournaments t ON t.id = bt.core_tournament_id AND t.deleted_at IS NULL
		JOIN core.calcuttas c ON c.tournament_id = t.id AND c.deleted_at IS NULL
		WHERE bt.id = $1
		ORDER BY c.created_at DESC
		LIMIT 1
	`

	var calcuttaID, tournamentID string
	if err := s.pool.QueryRow(ctx, query, bronzeTournamentID).Scan(&calcuttaID, &tournamentID); err != nil {
		return nil, err
	}
	return &calcuttaContext{CalcuttaID: calcuttaID, TournamentID: tournamentID}, nil
}

func (s *Service) createTournamentStateSnapshot(ctx context.Context, coreTournamentID string) (string, error) {
	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return "", err
	}
	defer func() {
		_ = tx.Rollback(ctx)
	}()

	var snapshotID string
	if err := tx.QueryRow(ctx, `
		INSERT INTO derived.simulation_states (tournament_id, source, description)
		VALUES ($1, 'simulated_calcutta', 'Autogenerated snapshot for simulated calcutta evaluation')
		RETURNING id
	`, coreTournamentID).Scan(&snapshotID); err != nil {
		return "", err
	}

	_, err = tx.Exec(ctx, `
		INSERT INTO derived.simulation_state_teams (
			simulation_state_id,
			team_id,
			wins,
			byes,
			eliminated
		)
		SELECT
			$1,
			ct.id,
			ct.wins,
			ct.byes,
			ct.eliminated
		FROM core.teams ct
		WHERE ct.tournament_id = $2
			AND ct.deleted_at IS NULL
		ON CONFLICT (simulation_state_id, team_id) DO NOTHING
	`, snapshotID, coreTournamentID)
	if err != nil {
		return "", err
	}

	if err := tx.Commit(ctx); err != nil {
		return "", err
	}
	return snapshotID, nil
}

func (s *Service) createTournamentSimulationBatch(ctx context.Context, bronzeTournamentID string, coreTournamentID string, tournamentStateSnapshotID string) (string, error) {
	var nSims int
	if err := s.pool.QueryRow(ctx, `
		SELECT COUNT(DISTINCT sim_id)::int
		FROM derived.simulated_teams
		WHERE tournament_id = $1
			AND simulated_tournament_id IS NULL
	`, bronzeTournamentID).Scan(&nSims); err != nil {
		return "", err
	}

	var batchID string
	if err := s.pool.QueryRow(ctx, `
		INSERT INTO derived.simulated_tournaments (
			tournament_id,
			simulation_state_id,
			n_sims,
			seed,
			probability_source_key
		)
		VALUES ($1, $2, $3, 0, 'legacy')
		RETURNING id
	`, coreTournamentID, tournamentStateSnapshotID, nSims).Scan(&batchID); err != nil {
		return "", err
	}

	return batchID, nil
}

func (s *Service) attachSimulationBatchToSimulatedTournaments(ctx context.Context, bronzeTournamentID string, tournamentSimulationBatchID string) error {
	_, err := s.pool.Exec(ctx, `
		UPDATE derived.simulated_teams
		SET simulated_tournament_id = $2
		WHERE tournament_id = $1
			AND simulated_tournament_id IS NULL
	`, bronzeTournamentID, tournamentSimulationBatchID)
	return err
}

func (s *Service) createCalcuttaSnapshot(ctx context.Context, calcuttaID string, coreTournamentID string, bronzeTournamentID string, runID string, excludedEntryName string) (string, error) {
	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return "", err
	}
	defer func() {
		_ = tx.Rollback(ctx)
	}()

	var snapshotID string
	if err := tx.QueryRow(ctx, `
		INSERT INTO core.calcutta_snapshots (base_calcutta_id, snapshot_type, description)
		VALUES ($1, 'simulated_calcutta', 'Autogenerated snapshot for simulated calcutta evaluation')
		RETURNING id
	`, calcuttaID).Scan(&snapshotID); err != nil {
		return "", err
	}

	// Snapshot payouts
	_, err = tx.Exec(ctx, `
		INSERT INTO core.calcutta_snapshot_payouts (calcutta_snapshot_id, position, amount_cents)
		SELECT $2, position, amount_cents
		FROM core.payouts
		WHERE calcutta_id = $1
			AND deleted_at IS NULL
	`, calcuttaID, snapshotID)
	if err != nil {
		return "", err
	}

	// Snapshot scoring rules
	_, err = tx.Exec(ctx, `
		INSERT INTO core.calcutta_snapshot_scoring_rules (calcutta_snapshot_id, win_index, points_awarded)
		SELECT $2, win_index, points_awarded
		FROM core.calcutta_scoring_rules
		WHERE calcutta_id = $1
			AND deleted_at IS NULL
	`, calcuttaID, snapshotID)
	if err != nil {
		return "", err
	}

	// Snapshot real entries and their bids
	entryRows, err := tx.Query(ctx, `
		SELECT id, name
		FROM core.entries
		WHERE calcutta_id = $1
			AND deleted_at IS NULL
			AND (name != $2 OR $2 = '')
		ORDER BY created_at ASC
	`, calcuttaID, excludedEntryName)
	if err != nil {
		return "", err
	}

	type entryRow struct {
		id   string
		name string
	}
	entries := make([]entryRow, 0)
	for entryRows.Next() {
		var entryID, entryName string
		if err := entryRows.Scan(&entryID, &entryName); err != nil {
			entryRows.Close()
			return "", err
		}
		entries = append(entries, entryRow{id: entryID, name: entryName})
	}
	if err := entryRows.Err(); err != nil {
		entryRows.Close()
		return "", err
	}
	entryRows.Close()

	for _, e := range entries {
		var snapshotEntryID string
		if err := tx.QueryRow(ctx, `
			INSERT INTO core.calcutta_snapshot_entries (calcutta_snapshot_id, entry_id, display_name, is_synthetic)
			VALUES ($1, $2, $3, false)
			RETURNING id
		`, snapshotID, e.id, e.name).Scan(&snapshotEntryID); err != nil {
			return "", err
		}

		_, err := tx.Exec(ctx, `
			INSERT INTO core.calcutta_snapshot_entry_teams (calcutta_snapshot_entry_id, team_id, bid_points)
			SELECT $1, team_id, bid_points
			FROM core.entry_teams
			WHERE entry_id = $2
				AND deleted_at IS NULL
		`, snapshotEntryID, e.id)
		if err != nil {
			return "", err
		}
	}

	// Snapshot our_strategy synthetic entry when a strategy_generation_run exists for this run_key.
	var strategyGenerationRunID string
	if err := tx.QueryRow(ctx, `
		SELECT id
		FROM derived.strategy_generation_runs
		WHERE run_key = $1::text
			AND deleted_at IS NULL
		ORDER BY created_at DESC
		LIMIT 1
	`, runID).Scan(&strategyGenerationRunID); err == nil {
		var snapshotEntryID string
		if err := tx.QueryRow(ctx, `
			INSERT INTO core.calcutta_snapshot_entries (calcutta_snapshot_id, entry_id, display_name, is_synthetic)
			VALUES ($1, NULL, 'Our Strategy', true)
			RETURNING id
		`, snapshotID).Scan(&snapshotEntryID); err != nil {
			return "", err
		}

		_, err := tx.Exec(ctx, `
			INSERT INTO core.calcutta_snapshot_entry_teams (calcutta_snapshot_entry_id, team_id, bid_points)
			SELECT
				$1,
				tt.id,
				reb.bid_points
			FROM derived.recommended_entry_bids reb
			JOIN derived.teams bt ON reb.team_id = bt.id
			JOIN core.schools s ON bt.school_name = s.name
			JOIN core.teams tt ON tt.school_id = s.id AND tt.tournament_id = $4
			WHERE reb.strategy_generation_run_id = $2::uuid
				AND bt.tournament_id = $3
				AND reb.deleted_at IS NULL
		`, snapshotEntryID, strategyGenerationRunID, bronzeTournamentID, coreTournamentID)
		if err != nil {
			return "", err
		}
	}

	if err := tx.Commit(ctx); err != nil {
		return "", err
	}
	return snapshotID, nil
}

func (s *Service) createCalcuttaEvaluationRun(ctx context.Context, tournamentSimulationBatchID string, calcuttaSnapshotID string) (string, error) {
	var evalID string
	if err := s.pool.QueryRow(ctx, `
		INSERT INTO derived.calcutta_evaluation_runs (simulated_tournament_id, calcutta_snapshot_id, purpose)
		VALUES ($1, $2, 'simulated_calcutta')
		RETURNING id
	`, tournamentSimulationBatchID, calcuttaSnapshotID).Scan(&evalID); err != nil {
		return "", err
	}
	return evalID, nil
}

func (s *Service) getEntries(ctx context.Context, bronzeTournamentID string, cc *calcuttaContext, runID string, excludedEntry string) (map[string]*Entry, error) {
	// Use canonical core tables for entries/bids.
	query := `
		SELECT
			ce.name as entry_name,
			cet.team_id,
			cet.bid_points as bid_points
		FROM core.entry_teams cet
		JOIN core.entries ce ON cet.entry_id = ce.id
		WHERE ce.calcutta_id = $1
		  AND cet.deleted_at IS NULL
		  AND ce.deleted_at IS NULL
		  AND (ce.name != $2 OR $2 = '')
	`

	rows, err := s.pool.Query(ctx, query, cc.CalcuttaID, excludedEntry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	entries := make(map[string]*Entry)
	for rows.Next() {
		var entryName, teamID string
		var bidPoints int
		if err := rows.Scan(&entryName, &teamID, &bidPoints); err != nil {
			return nil, err
		}

		if entries[entryName] == nil {
			entries[entryName] = &Entry{
				Name:  entryName,
				Teams: make(map[string]int),
			}
		}
		entries[entryName].Teams[teamID] = bidPoints
	}

	// Add our simulated entry from gold_recommended_entry_bids
	// Map bronze_teams IDs to core.teams IDs in this tournament.
	ourQuery := `
		SELECT 
			tt.id as tournament_team_id,
			greb.bid_points
		FROM derived.recommended_entry_bids greb
		JOIN derived.teams bt ON greb.team_id = bt.id
		JOIN core.schools s ON bt.school_name = s.name
		JOIN core.teams tt ON tt.school_id = s.id AND tt.tournament_id = $3
		WHERE greb.run_id = $1
		  AND bt.tournament_id = $2
	`

	ourRows, err := s.pool.Query(ctx, ourQuery, runID, bronzeTournamentID, cc.TournamentID)
	if err != nil {
		return nil, err
	}
	defer ourRows.Close()

	ourEntry := &Entry{
		Name:  "Our Strategy",
		Teams: make(map[string]int),
	}

	for ourRows.Next() {
		var teamID string
		var bidPoints int
		if err := ourRows.Scan(&teamID, &bidPoints); err != nil {
			return nil, err
		}
		ourEntry.Teams[teamID] = bidPoints
	}

	if len(ourEntry.Teams) > 0 {
		entries["Our Strategy"] = ourEntry
	}

	return entries, nil
}

func (s *Service) getSimulations(ctx context.Context, bronzeTournamentID string, cc *calcuttaContext, tournamentSimulationBatchID string) (map[int][]TeamSimResult, error) {
	// Simulations are keyed by bronze tournaments; map bronze teams to core teams in the resolved tournament.
	// Compute points using canonical scoring rules.
	query := `
		SELECT
			sst.sim_id,
			tt.id as tournament_team_id,
			core.calcutta_points_for_progress($3, sst.wins, sst.byes) as points
		FROM derived.simulated_teams sst
		JOIN derived.teams bt ON sst.team_id = bt.id
		JOIN core.schools s ON bt.school_name = s.name
		JOIN core.teams tt ON tt.school_id = s.id AND tt.tournament_id = $2
		WHERE sst.tournament_id = $1
			AND sst.simulated_tournament_id = $4
		ORDER BY sst.sim_id, tt.id
	`

	rows, err := s.pool.Query(ctx, query, bronzeTournamentID, cc.TournamentID, cc.CalcuttaID, tournamentSimulationBatchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	simulations := make(map[int][]TeamSimResult)

	for rows.Next() {
		var simID, points int
		var teamID string
		if err := rows.Scan(&simID, &teamID, &points); err != nil {
			return nil, err
		}
		simulations[simID] = append(simulations[simID], TeamSimResult{
			TeamID: teamID,
			Points: points,
		})
	}

	return simulations, nil
}

func (s *Service) getPayoutStructure(ctx context.Context, calcuttaID string) (map[int]int, int, error) {
	query := `
		SELECT position, amount_cents
		FROM core.payouts
		WHERE calcutta_id = $1
		  AND deleted_at IS NULL
		ORDER BY position
	`

	rows, err := s.pool.Query(ctx, query, calcuttaID)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	payouts := make(map[int]int)
	var firstPlacePayout int

	for rows.Next() {
		var position, amountCents int
		if err := rows.Scan(&position, &amountCents); err != nil {
			return nil, 0, err
		}
		payouts[position] = amountCents
		if position == 1 {
			firstPlacePayout = amountCents
		}
	}

	if firstPlacePayout == 0 {
		return nil, 0, fmt.Errorf("no first place payout found")
	}

	return payouts, firstPlacePayout, nil
}
