package calcutta_evaluations

import (
	"context"
	"fmt"

	"github.com/andrewcopp/Calcutta/backend/internal/app/scoring"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

type calcuttaContext struct {
	CalcuttaID   string
	TournamentID string
}

func (s *Service) getLatestTournamentSimulationBatchID(ctx context.Context, coreTournamentID string) (string, bool, error) {
	var batchID string
	err := s.pool.QueryRow(ctx, `
		SELECT b.id
		FROM derived.simulated_tournaments b
		WHERE b.tournament_id = $1
			AND b.deleted_at IS NULL
			AND EXISTS (
				SELECT 1
				FROM derived.simulated_teams st
				WHERE st.tournament_id = $1
					AND st.simulated_tournament_id = b.id
					AND st.deleted_at IS NULL
			)
		ORDER BY b.created_at DESC
		LIMIT 1
	`, coreTournamentID).Scan(&batchID)
	if err != nil {
		if err == pgx.ErrNoRows {
			return "", false, nil
		}
		return "", false, err
	}
	return batchID, true, nil
}

func (s *Service) getCalcuttaContext(ctx context.Context, calcuttaID string) (*calcuttaContext, error) {
	// Resolve a single calcutta_id (and its tournament_id) for a given bronze tournament.
	// This intentionally isolates the season/name join in one place.
	query := `
		SELECT c.id, c.tournament_id
		FROM core.calcuttas c
		WHERE c.id = $1::uuid
			AND c.deleted_at IS NULL
		LIMIT 1
	`

	var resolvedCalcuttaID, tournamentID string
	if err := s.pool.QueryRow(ctx, query, calcuttaID).Scan(&resolvedCalcuttaID, &tournamentID); err != nil {
		return nil, err
	}
	return &calcuttaContext{CalcuttaID: resolvedCalcuttaID, TournamentID: tournamentID}, nil
}

func (s *Service) createTournamentStateSnapshot(ctx context.Context, coreTournamentID string) (string, error) {
	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return "", err
	}
	defer func() {
		_ = tx.Rollback(ctx)
	}()

	var snapshotID string
	if err := tx.QueryRow(ctx, `
		INSERT INTO derived.simulation_states (tournament_id, source, description)
		VALUES ($1, 'simulated_calcutta', 'Autogenerated snapshot for simulated calcutta evaluation')
		RETURNING id
	`, coreTournamentID).Scan(&snapshotID); err != nil {
		return "", err
	}

	_, err = tx.Exec(ctx, `
		INSERT INTO derived.simulation_state_teams (
			simulation_state_id,
			team_id,
			wins,
			byes,
			eliminated
		)
		SELECT
			$1,
			ct.id,
			ct.wins,
			ct.byes,
			ct.eliminated
		FROM core.teams ct
		WHERE ct.tournament_id = $2
			AND ct.deleted_at IS NULL
		ON CONFLICT (simulation_state_id, team_id) DO NOTHING
	`, snapshotID, coreTournamentID)
	if err != nil {
		return "", err
	}

	if err := tx.Commit(ctx); err != nil {
		return "", err
	}
	return snapshotID, nil
}

func (s *Service) createTournamentSimulationBatch(ctx context.Context, coreTournamentID string, tournamentStateSnapshotID string) (string, error) {
	var nSims int
	if err := s.pool.QueryRow(ctx, `
		SELECT COUNT(DISTINCT sim_id)::int
		FROM derived.simulated_teams
		WHERE tournament_id = $1
			AND simulated_tournament_id IS NULL
	`, coreTournamentID).Scan(&nSims); err != nil {
		return "", err
	}

	var batchID string
	if err := s.pool.QueryRow(ctx, `
		INSERT INTO derived.simulated_tournaments (
			tournament_id,
			simulation_state_id,
			n_sims,
			seed,
			probability_source_key
		)
		VALUES ($1, $2, $3, 42, 'legacy')
		RETURNING id
	`, coreTournamentID, tournamentStateSnapshotID, nSims).Scan(&batchID); err != nil {
		return "", err
	}

	return batchID, nil
}

func (s *Service) attachSimulationBatchToSimulatedTournaments(ctx context.Context, coreTournamentID string, tournamentSimulationBatchID string) error {
	_, err := s.pool.Exec(ctx, `
		UPDATE derived.simulated_teams
		SET simulated_tournament_id = $2
		WHERE tournament_id = $1
			AND simulated_tournament_id IS NULL
	`, coreTournamentID, tournamentSimulationBatchID)
	return err
}

func (s *Service) createCalcuttaSnapshot(ctx context.Context, calcuttaID string, coreTournamentID string, runID string, excludedEntryName string, entryCandidateID *string, strategyGenerationRunID *string) (string, error) {
	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return "", err
	}
	defer func() {
		_ = tx.Rollback(ctx)
	}()

	var snapshotID string
	if err := tx.QueryRow(ctx, `
		INSERT INTO core.calcutta_snapshots (base_calcutta_id, snapshot_type, description)
		VALUES ($1::uuid, 'simulated_calcutta', 'Autogenerated snapshot for simulated calcutta evaluation')
		RETURNING id
	`, calcuttaID).Scan(&snapshotID); err != nil {
		return "", err
	}

	// Snapshot payouts
	_, err = tx.Exec(ctx, `
		INSERT INTO core.calcutta_snapshot_payouts (calcutta_snapshot_id, position, amount_cents)
		SELECT $2, position, amount_cents
		FROM core.payouts
		WHERE calcutta_id = $1::uuid
			AND deleted_at IS NULL
	`, calcuttaID, snapshotID)
	if err != nil {
		return "", err
	}

	// Snapshot scoring rules
	_, err = tx.Exec(ctx, `
		INSERT INTO core.calcutta_snapshot_scoring_rules (calcutta_snapshot_id, win_index, points_awarded)
		SELECT $2, win_index, points_awarded
		FROM core.calcutta_scoring_rules
		WHERE calcutta_id = $1::uuid
			AND deleted_at IS NULL
	`, calcuttaID, snapshotID)
	if err != nil {
		return "", err
	}

	// Snapshot real entries and their bids
	entryRows, err := tx.Query(ctx, `
		SELECT id, name
		FROM core.entries
		WHERE calcutta_id = $1::uuid
			AND deleted_at IS NULL
			AND (name != $2 OR $2 = '')
		ORDER BY created_at ASC
	`, calcuttaID, excludedEntryName)
	if err != nil {
		return "", err
	}

	type entryRow struct {
		id   string
		name string
	}
	entries := make([]entryRow, 0)
	for entryRows.Next() {
		var entryID, entryName string
		if err := entryRows.Scan(&entryID, &entryName); err != nil {
			entryRows.Close()
			return "", err
		}
		entries = append(entries, entryRow{id: entryID, name: entryName})
	}
	if err := entryRows.Err(); err != nil {
		entryRows.Close()
		return "", err
	}
	entryRows.Close()

	for _, e := range entries {
		var snapshotEntryID string
		if err := tx.QueryRow(ctx, `
			INSERT INTO core.calcutta_snapshot_entries (calcutta_snapshot_id, entry_id, display_name, is_synthetic)
			VALUES ($1, $2, $3, false)
			RETURNING id
		`, snapshotID, e.id, e.name).Scan(&snapshotEntryID); err != nil {
			return "", err
		}

		_, err := tx.Exec(ctx, `
			INSERT INTO core.calcutta_snapshot_entry_teams (calcutta_snapshot_entry_id, team_id, bid_points)
			SELECT $1, team_id, bid_points
			FROM core.entry_teams
			WHERE entry_id = $2::uuid
				AND deleted_at IS NULL
		`, snapshotEntryID, e.id)
		if err != nil {
			return "", err
		}
	}

	{
		var snapshotEntryID string
		if err := tx.QueryRow(ctx, `
			INSERT INTO core.calcutta_snapshot_entries (calcutta_snapshot_id, entry_id, display_name, is_synthetic)
			VALUES ($1, NULL, 'Our Strategy', true)
			RETURNING id
		`, snapshotID).Scan(&snapshotEntryID); err != nil {
			return "", err
		}

		if strategyGenerationRunID != nil && *strategyGenerationRunID != "" {
			_, err := tx.Exec(ctx, `
				INSERT INTO core.calcutta_snapshot_entry_teams (calcutta_snapshot_entry_id, team_id, bid_points)
				SELECT $1, greb.team_id, greb.bid_points
				FROM derived.strategy_generation_run_bids greb
				WHERE greb.strategy_generation_run_id = $2::uuid
					AND greb.deleted_at IS NULL
			`, snapshotEntryID, *strategyGenerationRunID)
			if err != nil {
				return "", err
			}
		} else {
			if _, parseErr := uuid.Parse(runID); parseErr == nil {
				_, err := tx.Exec(ctx, `
					INSERT INTO core.calcutta_snapshot_entry_teams (calcutta_snapshot_entry_id, team_id, bid_points)
					SELECT $1, greb.team_id, greb.bid_points
					FROM derived.strategy_generation_run_bids greb
					WHERE greb.run_id = $2::text
						AND greb.deleted_at IS NULL
				`, snapshotEntryID, runID)
				if err != nil {
					return "", err
				}
			}
		}
	}

	if entryCandidateID != nil && *entryCandidateID != "" {
		var snapshotEntryID string
		if err := tx.QueryRow(ctx, `
			INSERT INTO core.calcutta_snapshot_entries (calcutta_snapshot_id, entry_id, display_name, is_synthetic)
			VALUES ($1, NULL, 'Entry Candidate', true)
			RETURNING id
		`, snapshotID).Scan(&snapshotEntryID); err != nil {
			return "", err
		}

		_, err := tx.Exec(ctx, `
			INSERT INTO core.calcutta_snapshot_entry_teams (calcutta_snapshot_entry_id, team_id, bid_points)
			SELECT $1, ecb.team_id, ecb.bid_points
			FROM models.entry_candidate_bids ecb
			WHERE ecb.entry_candidate_id = $2::uuid
				AND ecb.deleted_at IS NULL
		`, snapshotEntryID, *entryCandidateID)
		if err != nil {
			return "", err
		}
	}

	if err := tx.Commit(ctx); err != nil {
		return "", err
	}
	return snapshotID, nil
}

func (s *Service) createCalcuttaEvaluationRun(ctx context.Context, tournamentSimulationBatchID string, calcuttaSnapshotID string) (string, error) {
	var evalID string
	if err := s.pool.QueryRow(ctx, `
		INSERT INTO derived.calcutta_evaluation_runs (simulated_tournament_id, calcutta_snapshot_id, purpose)
		VALUES ($1, $2, 'simulated_calcutta')
		RETURNING id
	`, tournamentSimulationBatchID, calcuttaSnapshotID).Scan(&evalID); err != nil {
		return "", err
	}
	return evalID, nil
}

func (s *Service) getEntries(ctx context.Context, cc *calcuttaContext, runID string, excludedEntry string, entryCandidateID *string, strategyGenerationRunID *string) (map[string]*Entry, error) {
	// Use canonical core tables for entries/bids.
	query := `
		SELECT
			ce.name as entry_name,
			cet.team_id,
			cet.bid_points as bid_points
		FROM core.entry_teams cet
		JOIN core.entries ce ON cet.entry_id = ce.id
		WHERE ce.calcutta_id = $1
		  AND cet.deleted_at IS NULL
		  AND ce.deleted_at IS NULL
		  AND (ce.name != $2 OR $2 = '')
	`

	rows, err := s.pool.Query(ctx, query, cc.CalcuttaID, excludedEntry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	entries := make(map[string]*Entry)
	for rows.Next() {
		var entryName, teamID string
		var bidPoints int
		if err := rows.Scan(&entryName, &teamID, &bidPoints); err != nil {
			return nil, err
		}

		if entries[entryName] == nil {
			entries[entryName] = &Entry{
				Name:  entryName,
				Teams: make(map[string]int),
			}
		}
		entries[entryName].Teams[teamID] = bidPoints
	}

	// Add our simulated entry.
	// Prefer using the strategy_generation_run_id when provided (Lab / deterministic entries).
	var ourRows pgx.Rows
	if strategyGenerationRunID != nil && *strategyGenerationRunID != "" {
		ourRows, err = s.pool.Query(ctx, `
			SELECT team_id, bid_points
			FROM derived.strategy_generation_run_bids greb
			WHERE greb.strategy_generation_run_id = $1::uuid
				AND greb.deleted_at IS NULL
		`, *strategyGenerationRunID)
	} else {
		ourRows, err = s.pool.Query(ctx, `
			SELECT team_id, bid_points
			FROM derived.strategy_generation_run_bids greb
			WHERE greb.run_id = $1::text
				AND greb.deleted_at IS NULL
		`, runID)
	}
	if err != nil {
		return nil, err
	}
	defer ourRows.Close()

	ourEntry := &Entry{
		Name:  "Our Strategy",
		Teams: make(map[string]int),
	}

	for ourRows.Next() {
		var teamID string
		var bidPoints int
		if err := ourRows.Scan(&teamID, &bidPoints); err != nil {
			return nil, err
		}
		ourEntry.Teams[teamID] = bidPoints
	}

	if len(ourEntry.Teams) > 0 {
		entries["Our Strategy"] = ourEntry
	}

	if entryCandidateID != nil && *entryCandidateID != "" {
		candidateRows, err := s.pool.Query(ctx, `
			SELECT team_id, bid_points
			FROM models.entry_candidate_bids
			WHERE entry_candidate_id = $1::uuid
				AND deleted_at IS NULL
		`, *entryCandidateID)
		if err != nil {
			return nil, err
		}
		defer candidateRows.Close()

		candidate := &Entry{Name: "Entry Candidate", Teams: make(map[string]int)}
		for candidateRows.Next() {
			var teamID string
			var bidPoints int
			if err := candidateRows.Scan(&teamID, &bidPoints); err != nil {
				return nil, err
			}
			candidate.Teams[teamID] = bidPoints
		}
		if len(candidate.Teams) > 0 {
			entries[candidate.Name] = candidate
		}
	}

	return entries, nil
}

func (s *Service) getSimulations(ctx context.Context, cc *calcuttaContext, tournamentSimulationBatchID string) (map[int][]TeamSimResult, error) {
	// Simulations are keyed by bronze tournaments; map bronze teams to core teams in the resolved tournament.
	// Compute points using canonical scoring rules.
	rules, err := s.loadCoreScoringRules(ctx, cc.CalcuttaID)
	if err != nil {
		return nil, err
	}
	return s.getSimulationsWithRules(ctx, cc.TournamentID, tournamentSimulationBatchID, rules)
}

func (s *Service) getSimulationsWithRules(ctx context.Context, tournamentID string, tournamentSimulationBatchID string, rules []scoring.Rule) (map[int][]TeamSimResult, error) {
	query := `
		SELECT
			sst.sim_id,
			sst.team_id,
			sst.wins::int,
			sst.byes::int
		FROM derived.simulated_teams sst
		WHERE sst.tournament_id = $1
			AND sst.simulated_tournament_id = $2
			AND sst.deleted_at IS NULL
		ORDER BY sst.sim_id, sst.team_id
	`

	rows, err := s.pool.Query(ctx, query, tournamentID, tournamentSimulationBatchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	simulations := make(map[int][]TeamSimResult)

	for rows.Next() {
		var simID int
		var teamID string
		var wins int
		var byes int
		if err := rows.Scan(&simID, &teamID, &wins, &byes); err != nil {
			return nil, err
		}
		points := scoring.PointsForProgress(rules, wins, byes)
		simulations[simID] = append(simulations[simID], TeamSimResult{
			TeamID: teamID,
			Points: points,
		})
	}

	return simulations, nil
}

func (s *Service) loadCoreScoringRules(ctx context.Context, calcuttaID string) ([]scoring.Rule, error) {
	rows, err := s.pool.Query(ctx, `
		SELECT win_index::int, points_awarded::int
		FROM core.calcutta_scoring_rules
		WHERE calcutta_id = $1::uuid
			AND deleted_at IS NULL
		ORDER BY win_index ASC
	`, calcuttaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	rules := make([]scoring.Rule, 0)
	for rows.Next() {
		var r scoring.Rule
		if err := rows.Scan(&r.WinIndex, &r.PointsAwarded); err != nil {
			return nil, err
		}
		rules = append(rules, r)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return rules, nil
}

func (s *Service) loadSimulatedCalcuttaScoringRules(ctx context.Context, simulatedCalcuttaID string) ([]scoring.Rule, error) {
	rows, err := s.pool.Query(ctx, `
		SELECT win_index::int, points_awarded::int
		FROM derived.simulated_calcutta_scoring_rules
		WHERE simulated_calcutta_id = $1::uuid
			AND deleted_at IS NULL
		ORDER BY win_index ASC
	`, simulatedCalcuttaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	rules := make([]scoring.Rule, 0)
	for rows.Next() {
		var r scoring.Rule
		if err := rows.Scan(&r.WinIndex, &r.PointsAwarded); err != nil {
			return nil, err
		}
		rules = append(rules, r)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return rules, nil
}

func (s *Service) getPayoutStructureFromSimulatedCalcutta(ctx context.Context, simulatedCalcuttaID string) (map[int]int, int, error) {
	rows, err := s.pool.Query(ctx, `
		SELECT position::int, amount_cents::int
		FROM derived.simulated_calcutta_payouts
		WHERE simulated_calcutta_id = $1::uuid
			AND deleted_at IS NULL
		ORDER BY position ASC
	`, simulatedCalcuttaID)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	payouts := make(map[int]int)
	firstPlace := 0
	for rows.Next() {
		var position int
		var amountCents int
		if err := rows.Scan(&position, &amountCents); err != nil {
			return nil, 0, err
		}
		payouts[position] = amountCents
		if position == 1 {
			firstPlace = amountCents
		}
	}
	if err := rows.Err(); err != nil {
		return nil, 0, err
	}
	if firstPlace == 0 {
		return nil, 0, fmt.Errorf("no first place payout found")
	}
	return payouts, firstPlace, nil
}

func (s *Service) getEntriesFromSimulatedCalcutta(ctx context.Context, simulatedCalcuttaID string, excludedEntryName string) (map[string]*Entry, error) {
	rows, err := s.pool.Query(ctx, `
		SELECT
			se.display_name,
			set.team_id::text,
			set.bid_points::int
		FROM derived.simulated_entries se
		JOIN derived.simulated_entry_teams set
			ON set.simulated_entry_id = se.id
			AND set.deleted_at IS NULL
		WHERE se.simulated_calcutta_id = $1::uuid
			AND se.deleted_at IS NULL
			AND (se.display_name != $2 OR $2 = '')
		ORDER BY se.created_at ASC
	`, simulatedCalcuttaID, excludedEntryName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	entries := make(map[string]*Entry)
	for rows.Next() {
		var entryName string
		var teamID string
		var bidPoints int
		if err := rows.Scan(&entryName, &teamID, &bidPoints); err != nil {
			return nil, err
		}
		if entries[entryName] == nil {
			entries[entryName] = &Entry{Name: entryName, Teams: make(map[string]int)}
		}
		entries[entryName].Teams[teamID] = bidPoints
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return entries, nil
}

func (s *Service) createCalcuttaEvaluationRunForSimulatedCalcutta(ctx context.Context, tournamentSimulationBatchID string, simulatedCalcuttaID string) (string, error) {
	var evalID string
	if err := s.pool.QueryRow(ctx, `
		INSERT INTO derived.calcutta_evaluation_runs (
			simulated_tournament_id,
			calcutta_snapshot_id,
			simulated_calcutta_id,
			purpose
		)
		VALUES ($1::uuid, NULL, $2::uuid, 'simulated_calcutta')
		RETURNING id
	`, tournamentSimulationBatchID, simulatedCalcuttaID).Scan(&evalID); err != nil {
		return "", err
	}
	return evalID, nil
}

func (s *Service) getPayoutStructure(ctx context.Context, calcuttaID string) (map[int]int, int, error) {
	query := `
		SELECT position, amount_cents
		FROM core.payouts
		WHERE calcutta_id = $1
		  AND deleted_at IS NULL
		ORDER BY position
	`

	rows, err := s.pool.Query(ctx, query, calcuttaID)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	payouts := make(map[int]int)
	var firstPlacePayout int

	for rows.Next() {
		var position, amountCents int
		if err := rows.Scan(&position, &amountCents); err != nil {
			return nil, 0, err
		}
		payouts[position] = amountCents
		if position == 1 {
			firstPlacePayout = amountCents
		}
	}

	if firstPlacePayout == 0 {
		return nil, 0, fmt.Errorf("no first place payout found")
	}

	return payouts, firstPlacePayout, nil
}
