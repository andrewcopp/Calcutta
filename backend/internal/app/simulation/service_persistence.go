package simulation

import (
	"context"
	"errors"
	"fmt"

	"github.com/andrewcopp/Calcutta/backend/internal/models"
	"github.com/jackc/pgx/v5"
)

func (s *Service) createTournamentStateSnapshotFromBracket(
	ctx context.Context,
	coreTournamentID string,
	br *models.BracketStructure,
	teams []*models.TournamentTeam,
) (string, error) {
	if br == nil {
		return "", errors.New("bracket must not be nil")
	}

	tx, err := s.pool.BeginTx(ctx, pgx.TxOptions{})
	if err != nil {
		return "", fmt.Errorf("beginning transaction: %w", err)
	}
	defer func() { _ = tx.Rollback(ctx) }()

	var snapshotID string
	if err := tx.QueryRow(ctx, `
		INSERT INTO derived.tournament_snapshots (tournament_id, source, description)
		VALUES ($1, 'go_simulate_tournaments', 'Snapshot from bracket state (post_first_four)')
		RETURNING id
	`, coreTournamentID).Scan(&snapshotID); err != nil {
		return "", fmt.Errorf("inserting tournament snapshot: %w", err)
	}

	for _, t := range teams {
		if t == nil || t.ID == "" {
			continue
		}
		coreTeamID := t.ID
		wins, byes, isEliminated := models.CalculateWinsAndByes(coreTeamID, br)
		_, err := tx.Exec(ctx, `
			INSERT INTO derived.tournament_snapshot_teams (
				tournament_snapshot_id,
				team_id,
				wins,
				byes,
				is_eliminated
			)
			VALUES ($1, $2::uuid, $3, $4, $5)
			ON CONFLICT (tournament_snapshot_id, team_id) DO NOTHING
		`, snapshotID, coreTeamID, wins, byes, isEliminated)
		if err != nil {
			return "", fmt.Errorf("inserting snapshot team %s: %w", coreTeamID, err)
		}
	}

	if err := tx.Commit(ctx); err != nil {
		return "", fmt.Errorf("committing snapshot transaction: %w", err)
	}

	return snapshotID, nil
}

func (s *Service) createTournamentStateSnapshot(ctx context.Context, coreTournamentID string) (string, error) {
	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return "", fmt.Errorf("beginning transaction: %w", err)
	}
	defer func() { _ = tx.Rollback(ctx) }()

	var snapshotID string
	if err := tx.QueryRow(ctx, `
		INSERT INTO derived.tournament_snapshots (tournament_id, source, description)
		VALUES ($1, 'go_simulate_tournaments', 'Autogenerated snapshot for tournament simulation batch')
		RETURNING id
	`, coreTournamentID).Scan(&snapshotID); err != nil {
		return "", fmt.Errorf("inserting tournament snapshot: %w", err)
	}

	_, err = tx.Exec(ctx, `
		INSERT INTO derived.tournament_snapshot_teams (
			tournament_snapshot_id,
			team_id,
			wins,
			byes,
			is_eliminated
		)
		SELECT
			$1,
			ct.id,
			ct.wins,
			ct.byes,
			ct.is_eliminated
		FROM core.teams ct
		WHERE ct.tournament_id = $2
		  AND ct.deleted_at IS NULL
		ON CONFLICT (tournament_snapshot_id, team_id) DO NOTHING
	`, snapshotID, coreTournamentID)
	if err != nil {
		return "", fmt.Errorf("inserting snapshot teams: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return "", fmt.Errorf("committing snapshot transaction: %w", err)
	}

	return snapshotID, nil
}

func (s *Service) createTournamentSimulationBatch(
	ctx context.Context,
	coreTournamentID string,
	snapshotID string,
	nSims int,
	seed int,
	probabilitySourceKey string,
) (string, error) {
	var batchID string
	if err := s.pool.QueryRow(ctx, `
		INSERT INTO derived.simulated_tournaments (
			tournament_id,
			tournament_snapshot_id,
			n_sims,
			seed,
			probability_source_key
		)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id
	`, coreTournamentID, snapshotID, nSims, seed, probabilitySourceKey).Scan(&batchID); err != nil {
		return "", fmt.Errorf("creating simulation batch: %w", err)
	}
	return batchID, nil
}

type simResultsSource struct {
	batchID      string
	tournamentID string
	simOffset    int
	results      []TeamSimulationResult
	idx          int
}

func (s *simResultsSource) Next() bool {
	return s.idx < len(s.results)
}

func (s *simResultsSource) Values() ([]any, error) {
	r := s.results[s.idx]
	s.idx++
	return []any{
		s.batchID,
		s.tournamentID,
		r.SimID + s.simOffset,
		r.TeamID,
		r.Wins,
		r.Byes,
		r.IsEliminated,
	}, nil
}

func (s *simResultsSource) Err() error { return nil }

func (s *Service) copyInsertSimulatedTournaments(
	ctx context.Context,
	batchID string,
	tournamentID string,
	simOffset int,
	results []TeamSimulationResult,
) (int64, error) {
	conn, err := s.pool.Acquire(ctx)
	if err != nil {
		return 0, fmt.Errorf("acquiring connection: %w", err)
	}
	defer conn.Release()

	src := &simResultsSource{
		batchID:      batchID,
		tournamentID: tournamentID,
		simOffset:    simOffset,
		results:      results,
		idx:          0,
	}

	inserted, err := conn.Conn().CopyFrom(
		ctx,
		pgx.Identifier{"derived", "simulated_teams"},
		[]string{"simulated_tournament_id", "tournament_id", "sim_id", "team_id", "wins", "byes", "is_eliminated"},
		src,
	)
	if err != nil {
		return 0, fmt.Errorf("copy inserting simulated teams: %w", err)
	}
	return inserted, nil
}
