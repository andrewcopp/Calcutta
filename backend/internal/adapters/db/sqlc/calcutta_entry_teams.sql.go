// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: calcutta_entry_teams.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEntryTeam = `-- name: CreateEntryTeam :exec
INSERT INTO core.entry_teams (id, entry_id, team_id, bid_points, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateEntryTeamParams struct {
	ID        string
	EntryID   string
	TeamID    string
	BidPoints int32
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) CreateEntryTeam(ctx context.Context, arg CreateEntryTeamParams) error {
	_, err := q.db.Exec(ctx, createEntryTeam,
		arg.ID,
		arg.EntryID,
		arg.TeamID,
		arg.BidPoints,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const listEntryTeamsByEntryID = `-- name: ListEntryTeamsByEntryID :many
SELECT
    cet.id,
    cet.entry_id,
    cet.team_id,
    cet.bid_points,
    cet.created_at,
    cet.updated_at,
    cet.deleted_at,
    tt.id AS tournament_team_id,
    tt.school_id,
    tt.tournament_id,
    tt.seed,
    tt.region,
    tt.byes,
    tt.wins,
    tt.created_at AS team_created_at,
    tt.updated_at AS team_updated_at,
    tt.deleted_at AS team_deleted_at,
    s.name AS school_name
FROM core.entry_teams cet
JOIN core.teams tt ON cet.team_id = tt.id
LEFT JOIN core.schools s ON tt.school_id = s.id
WHERE cet.entry_id = $1 AND cet.deleted_at IS NULL
ORDER BY cet.created_at DESC
`

type ListEntryTeamsByEntryIDRow struct {
	ID               string
	EntryID          string
	TeamID           string
	BidPoints        int32
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	DeletedAt        pgtype.Timestamptz
	TournamentTeamID string
	SchoolID         string
	TournamentID     string
	Seed             int32
	Region           string
	Byes             int32
	Wins             int32
	TeamCreatedAt    pgtype.Timestamptz
	TeamUpdatedAt    pgtype.Timestamptz
	TeamDeletedAt    pgtype.Timestamptz
	SchoolName       *string
}

func (q *Queries) ListEntryTeamsByEntryID(ctx context.Context, entryID string) ([]ListEntryTeamsByEntryIDRow, error) {
	rows, err := q.db.Query(ctx, listEntryTeamsByEntryID, entryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEntryTeamsByEntryIDRow
	for rows.Next() {
		var i ListEntryTeamsByEntryIDRow
		if err := rows.Scan(
			&i.ID,
			&i.EntryID,
			&i.TeamID,
			&i.BidPoints,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TournamentTeamID,
			&i.SchoolID,
			&i.TournamentID,
			&i.Seed,
			&i.Region,
			&i.Byes,
			&i.Wins,
			&i.TeamCreatedAt,
			&i.TeamUpdatedAt,
			&i.TeamDeletedAt,
			&i.SchoolName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntryTeamsByEntryIDs = `-- name: ListEntryTeamsByEntryIDs :many
SELECT
    cet.id,
    cet.entry_id,
    cet.team_id,
    cet.bid_points,
    cet.created_at,
    cet.updated_at,
    cet.deleted_at,
    tt.id AS tournament_team_id,
    tt.school_id,
    tt.tournament_id,
    tt.seed,
    tt.region,
    tt.byes,
    tt.wins,
    tt.created_at AS team_created_at,
    tt.updated_at AS team_updated_at,
    tt.deleted_at AS team_deleted_at,
    s.name AS school_name
FROM core.entry_teams cet
JOIN core.teams tt ON cet.team_id = tt.id
LEFT JOIN core.schools s ON tt.school_id = s.id
WHERE cet.entry_id = ANY($1::uuid[]) AND cet.deleted_at IS NULL
ORDER BY cet.created_at DESC
`

type ListEntryTeamsByEntryIDsRow struct {
	ID               string
	EntryID          string
	TeamID           string
	BidPoints        int32
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	DeletedAt        pgtype.Timestamptz
	TournamentTeamID string
	SchoolID         string
	TournamentID     string
	Seed             int32
	Region           string
	Byes             int32
	Wins             int32
	TeamCreatedAt    pgtype.Timestamptz
	TeamUpdatedAt    pgtype.Timestamptz
	TeamDeletedAt    pgtype.Timestamptz
	SchoolName       *string
}

func (q *Queries) ListEntryTeamsByEntryIDs(ctx context.Context, entryIds []string) ([]ListEntryTeamsByEntryIDsRow, error) {
	rows, err := q.db.Query(ctx, listEntryTeamsByEntryIDs, entryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEntryTeamsByEntryIDsRow
	for rows.Next() {
		var i ListEntryTeamsByEntryIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.EntryID,
			&i.TeamID,
			&i.BidPoints,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TournamentTeamID,
			&i.SchoolID,
			&i.TournamentID,
			&i.Seed,
			&i.Region,
			&i.Byes,
			&i.Wins,
			&i.TeamCreatedAt,
			&i.TeamUpdatedAt,
			&i.TeamDeletedAt,
			&i.SchoolName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteEntryTeamsByEntryID = `-- name: SoftDeleteEntryTeamsByEntryID :execrows
UPDATE core.entry_teams
SET deleted_at = $1,
    updated_at = $1
WHERE entry_id = $2 AND deleted_at IS NULL
`

type SoftDeleteEntryTeamsByEntryIDParams struct {
	DeletedAt pgtype.Timestamptz
	EntryID   string
}

func (q *Queries) SoftDeleteEntryTeamsByEntryID(ctx context.Context, arg SoftDeleteEntryTeamsByEntryIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteEntryTeamsByEntryID, arg.DeletedAt, arg.EntryID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
