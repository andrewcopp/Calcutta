// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: calcutta_entry_teams.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listEntryTeamsByEntryID = `-- name: ListEntryTeamsByEntryID :many
SELECT
    cet.id,
    cet.entry_id,
    cet.team_id,
    cet.bid,
    cet.created_at,
    cet.updated_at,
    cet.deleted_at,
    tt.id AS tournament_team_id,
    tt.school_id,
    tt.tournament_id,
    tt.seed,
    tt.byes,
    tt.wins,
    tt.created_at AS team_created_at,
    tt.updated_at AS team_updated_at,
    tt.deleted_at AS team_deleted_at,
    s.name AS school_name
FROM calcutta_entry_teams cet
JOIN tournament_teams tt ON cet.team_id = tt.id
LEFT JOIN schools s ON tt.school_id = s.id
WHERE cet.entry_id = $1 AND cet.deleted_at IS NULL
ORDER BY cet.created_at DESC
`

type ListEntryTeamsByEntryIDRow struct {
	ID               string
	EntryID          string
	TeamID           string
	Bid              int32
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	DeletedAt        pgtype.Timestamptz
	TournamentTeamID string
	SchoolID         string
	TournamentID     string
	Seed             int32
	Byes             int32
	Wins             int32
	TeamCreatedAt    pgtype.Timestamptz
	TeamUpdatedAt    pgtype.Timestamptz
	TeamDeletedAt    pgtype.Timestamptz
	SchoolName       *string
}

func (q *Queries) ListEntryTeamsByEntryID(ctx context.Context, entryID string) ([]ListEntryTeamsByEntryIDRow, error) {
	rows, err := q.db.Query(ctx, listEntryTeamsByEntryID, entryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEntryTeamsByEntryIDRow
	for rows.Next() {
		var i ListEntryTeamsByEntryIDRow
		if err := rows.Scan(
			&i.ID,
			&i.EntryID,
			&i.TeamID,
			&i.Bid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TournamentTeamID,
			&i.SchoolID,
			&i.TournamentID,
			&i.Seed,
			&i.Byes,
			&i.Wins,
			&i.TeamCreatedAt,
			&i.TeamUpdatedAt,
			&i.TeamDeletedAt,
			&i.SchoolName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteEntryTeamsByEntryID = `-- name: SoftDeleteEntryTeamsByEntryID :execrows
UPDATE calcutta_entry_teams
SET deleted_at = $1,
    updated_at = $1
WHERE entry_id = $2 AND deleted_at IS NULL
`

type SoftDeleteEntryTeamsByEntryIDParams struct {
	DeletedAt pgtype.Timestamptz
	EntryID   string
}

func (q *Queries) SoftDeleteEntryTeamsByEntryID(ctx context.Context, arg SoftDeleteEntryTeamsByEntryIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteEntryTeamsByEntryID, arg.DeletedAt, arg.EntryID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createEntryTeam = `-- name: CreateEntryTeam :exec
INSERT INTO calcutta_entry_teams (id, entry_id, team_id, bid, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateEntryTeamParams struct {
	ID        string
	EntryID   string
	TeamID    string
	Bid       int32
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) CreateEntryTeam(ctx context.Context, arg CreateEntryTeamParams) error {
	_, err := q.db.Exec(ctx, createEntryTeam,
		arg.ID,
		arg.EntryID,
		arg.TeamID,
		arg.Bid,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
