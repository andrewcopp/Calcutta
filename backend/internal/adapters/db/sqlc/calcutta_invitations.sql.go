// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: calcutta_invitations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptCalcuttaInvitation = `-- name: AcceptCalcuttaInvitation :execrows
UPDATE core.calcutta_invitations
SET status = 'accepted',
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) AcceptCalcuttaInvitation(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, acceptCalcuttaInvitation, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createCalcuttaInvitation = `-- name: CreateCalcuttaInvitation :exec
INSERT INTO core.calcutta_invitations (id, calcutta_id, user_id, invited_by, status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
`

type CreateCalcuttaInvitationParams struct {
	ID         string
	CalcuttaID string
	UserID     string
	InvitedBy  string
	Status     string
}

func (q *Queries) CreateCalcuttaInvitation(ctx context.Context, arg CreateCalcuttaInvitationParams) error {
	_, err := q.db.Exec(ctx, createCalcuttaInvitation,
		arg.ID,
		arg.CalcuttaID,
		arg.UserID,
		arg.InvitedBy,
		arg.Status,
	)
	return err
}

const getCalcuttaInvitationByCalcuttaAndUser = `-- name: GetCalcuttaInvitationByCalcuttaAndUser :one
SELECT id, calcutta_id, user_id, invited_by, status, created_at, updated_at
FROM core.calcutta_invitations
WHERE calcutta_id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type GetCalcuttaInvitationByCalcuttaAndUserParams struct {
	CalcuttaID string
	UserID     string
}

type GetCalcuttaInvitationByCalcuttaAndUserRow struct {
	ID         string
	CalcuttaID string
	UserID     string
	InvitedBy  string
	Status     string
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
}

func (q *Queries) GetCalcuttaInvitationByCalcuttaAndUser(ctx context.Context, arg GetCalcuttaInvitationByCalcuttaAndUserParams) (GetCalcuttaInvitationByCalcuttaAndUserRow, error) {
	row := q.db.QueryRow(ctx, getCalcuttaInvitationByCalcuttaAndUser, arg.CalcuttaID, arg.UserID)
	var i GetCalcuttaInvitationByCalcuttaAndUserRow
	err := row.Scan(
		&i.ID,
		&i.CalcuttaID,
		&i.UserID,
		&i.InvitedBy,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCalcuttaInvitationsByCalcuttaID = `-- name: ListCalcuttaInvitationsByCalcuttaID :many
SELECT id, calcutta_id, user_id, invited_by, status, created_at, updated_at
FROM core.calcutta_invitations
WHERE calcutta_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListCalcuttaInvitationsByCalcuttaIDRow struct {
	ID         string
	CalcuttaID string
	UserID     string
	InvitedBy  string
	Status     string
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
}

func (q *Queries) ListCalcuttaInvitationsByCalcuttaID(ctx context.Context, calcuttaID string) ([]ListCalcuttaInvitationsByCalcuttaIDRow, error) {
	rows, err := q.db.Query(ctx, listCalcuttaInvitationsByCalcuttaID, calcuttaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCalcuttaInvitationsByCalcuttaIDRow
	for rows.Next() {
		var i ListCalcuttaInvitationsByCalcuttaIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CalcuttaID,
			&i.UserID,
			&i.InvitedBy,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
