// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tournament_teams.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTeam = `-- name: CreateTeam :exec
INSERT INTO core.teams (
  id,
  tournament_id,
  school_id,
  seed,
  region,
  byes,
  wins,
  is_eliminated,
  created_at,
  updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type CreateTeamParams struct {
	ID           string
	TournamentID string
	SchoolID     string
	Seed         int32
	Region       string
	Byes         int32
	Wins         int32
	IsEliminated bool
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) error {
	_, err := q.db.Exec(ctx, createTeam,
		arg.ID,
		arg.TournamentID,
		arg.SchoolID,
		arg.Seed,
		arg.Region,
		arg.Byes,
		arg.Wins,
		arg.IsEliminated,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const getTeamByID = `-- name: GetTeamByID :one
SELECT
  tt.id,
  tt.tournament_id,
  tt.school_id,
  tt.seed,
  tt.region,
  tt.byes,
  tt.wins,
  tt.is_eliminated,
  tt.created_at,
  tt.updated_at,
  kps.net_rtg,
  kps.o_rtg,
  kps.d_rtg,
  kps.adj_t,
  s.name AS school_name
FROM core.teams tt
LEFT JOIN core.team_kenpom_stats kps ON kps.team_id = tt.id AND kps.deleted_at IS NULL
LEFT JOIN core.schools s ON tt.school_id = s.id
WHERE tt.id = $1 AND tt.deleted_at IS NULL
`

type GetTeamByIDRow struct {
	ID           string
	TournamentID string
	SchoolID     string
	Seed         int32
	Region       string
	Byes         int32
	Wins         int32
	IsEliminated bool
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	NetRtg       *float64
	ORtg         *float64
	DRtg         *float64
	AdjT         *float64
	SchoolName   *string
}

func (q *Queries) GetTeamByID(ctx context.Context, id string) (GetTeamByIDRow, error) {
	row := q.db.QueryRow(ctx, getTeamByID, id)
	var i GetTeamByIDRow
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.SchoolID,
		&i.Seed,
		&i.Region,
		&i.Byes,
		&i.Wins,
		&i.IsEliminated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NetRtg,
		&i.ORtg,
		&i.DRtg,
		&i.AdjT,
		&i.SchoolName,
	)
	return i, err
}

const getWinningTeam = `-- name: GetWinningTeam :one
SELECT
  tt.id,
  tt.tournament_id,
  tt.school_id,
  tt.seed,
  tt.region,
  tt.byes,
  tt.wins,
  tt.is_eliminated,
  tt.created_at,
  tt.updated_at,
  kps.net_rtg,
  kps.o_rtg,
  kps.d_rtg,
  kps.adj_t
FROM core.teams tt
LEFT JOIN core.team_kenpom_stats kps ON kps.team_id = tt.id AND kps.deleted_at IS NULL
WHERE tt.tournament_id = $1 AND tt.deleted_at IS NULL
ORDER BY tt.wins DESC
LIMIT 1
`

type GetWinningTeamRow struct {
	ID           string
	TournamentID string
	SchoolID     string
	Seed         int32
	Region       string
	Byes         int32
	Wins         int32
	IsEliminated bool
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	NetRtg       *float64
	ORtg         *float64
	DRtg         *float64
	AdjT         *float64
}

func (q *Queries) GetWinningTeam(ctx context.Context, tournamentID string) (GetWinningTeamRow, error) {
	row := q.db.QueryRow(ctx, getWinningTeam, tournamentID)
	var i GetWinningTeamRow
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.SchoolID,
		&i.Seed,
		&i.Region,
		&i.Byes,
		&i.Wins,
		&i.IsEliminated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NetRtg,
		&i.ORtg,
		&i.DRtg,
		&i.AdjT,
	)
	return i, err
}

const listTeamsByTournamentID = `-- name: ListTeamsByTournamentID :many
SELECT
  tt.id,
  tt.tournament_id,
  tt.school_id,
  tt.seed,
  tt.region,
  tt.byes,
  tt.wins,
  tt.is_eliminated,
  tt.created_at,
  tt.updated_at,
  kps.net_rtg,
  kps.o_rtg,
  kps.d_rtg,
  kps.adj_t,
  s.name AS school_name
FROM core.teams tt
LEFT JOIN core.team_kenpom_stats kps ON kps.team_id = tt.id AND kps.deleted_at IS NULL
LEFT JOIN core.schools s ON tt.school_id = s.id
WHERE tt.tournament_id = $1 AND tt.deleted_at IS NULL
ORDER BY tt.seed ASC
`

type ListTeamsByTournamentIDRow struct {
	ID           string
	TournamentID string
	SchoolID     string
	Seed         int32
	Region       string
	Byes         int32
	Wins         int32
	IsEliminated bool
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	NetRtg       *float64
	ORtg         *float64
	DRtg         *float64
	AdjT         *float64
	SchoolName   *string
}

func (q *Queries) ListTeamsByTournamentID(ctx context.Context, tournamentID string) ([]ListTeamsByTournamentIDRow, error) {
	rows, err := q.db.Query(ctx, listTeamsByTournamentID, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTeamsByTournamentIDRow
	for rows.Next() {
		var i ListTeamsByTournamentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.TournamentID,
			&i.SchoolID,
			&i.Seed,
			&i.Region,
			&i.Byes,
			&i.Wins,
			&i.IsEliminated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NetRtg,
			&i.ORtg,
			&i.DRtg,
			&i.AdjT,
			&i.SchoolName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWinningTeams = `-- name: ListWinningTeams :many
SELECT DISTINCT ON (tt.tournament_id)
  tt.id,
  tt.tournament_id,
  tt.school_id,
  tt.seed,
  tt.region,
  tt.byes,
  tt.wins,
  tt.is_eliminated,
  tt.created_at,
  tt.updated_at,
  kps.net_rtg,
  kps.o_rtg,
  kps.d_rtg,
  kps.adj_t
FROM core.teams tt
LEFT JOIN core.team_kenpom_stats kps ON kps.team_id = tt.id AND kps.deleted_at IS NULL
WHERE tt.deleted_at IS NULL AND tt.wins > 0
ORDER BY tt.tournament_id, tt.wins DESC
`

type ListWinningTeamsRow struct {
	ID           string
	TournamentID string
	SchoolID     string
	Seed         int32
	Region       string
	Byes         int32
	Wins         int32
	IsEliminated bool
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	NetRtg       *float64
	ORtg         *float64
	DRtg         *float64
	AdjT         *float64
}

func (q *Queries) ListWinningTeams(ctx context.Context) ([]ListWinningTeamsRow, error) {
	rows, err := q.db.Query(ctx, listWinningTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWinningTeamsRow
	for rows.Next() {
		var i ListWinningTeamsRow
		if err := rows.Scan(
			&i.ID,
			&i.TournamentID,
			&i.SchoolID,
			&i.Seed,
			&i.Region,
			&i.Byes,
			&i.Wins,
			&i.IsEliminated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NetRtg,
			&i.ORtg,
			&i.DRtg,
			&i.AdjT,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteTeamsByTournamentID = `-- name: SoftDeleteTeamsByTournamentID :execrows
UPDATE core.teams
SET deleted_at = $1,
    updated_at = $1
WHERE tournament_id = $2 AND deleted_at IS NULL
`

type SoftDeleteTeamsByTournamentIDParams struct {
	DeletedAt    pgtype.Timestamptz
	TournamentID string
}

func (q *Queries) SoftDeleteTeamsByTournamentID(ctx context.Context, arg SoftDeleteTeamsByTournamentIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteTeamsByTournamentID, arg.DeletedAt, arg.TournamentID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateTeam = `-- name: UpdateTeam :exec
UPDATE core.teams
SET wins = $1,
    byes = $2,
    is_eliminated = $3,
    updated_at = NOW()
WHERE id = $4 AND deleted_at IS NULL
`

type UpdateTeamParams struct {
	Wins       int32
	Byes       int32
	IsEliminated bool
	ID         string
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) error {
	_, err := q.db.Exec(ctx, updateTeam,
		arg.Wins,
		arg.Byes,
		arg.IsEliminated,
		arg.ID,
	)
	return err
}
