// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tournament_teams.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTournamentTeam = `-- name: CreateTournamentTeam :exec
INSERT INTO core.teams (
  id,
  tournament_id,
  school_id,
  seed,
  region,
  byes,
  wins,
  eliminated,
  created_at,
  updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type CreateTournamentTeamParams struct {
	ID           string
	TournamentID string
	SchoolID     string
	Seed         int32
	Region       string
	Byes         int32
	Wins         int32
	Eliminated   bool
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
}

func (q *Queries) CreateTournamentTeam(ctx context.Context, arg CreateTournamentTeamParams) error {
	_, err := q.db.Exec(ctx, createTournamentTeam,
		arg.ID,
		arg.TournamentID,
		arg.SchoolID,
		arg.Seed,
		arg.Region,
		arg.Byes,
		arg.Wins,
		arg.Eliminated,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const getTournamentTeamByID = `-- name: GetTournamentTeamByID :one
SELECT
  tt.id,
  tt.tournament_id,
  tt.school_id,
  tt.seed,
  tt.region,
  tt.byes,
  tt.wins,
  tt.eliminated,
  tt.created_at,
  tt.updated_at,
  kps.net_rtg,
  kps.o_rtg,
  kps.d_rtg,
  kps.adj_t,
  s.name AS school_name
FROM core.teams tt
LEFT JOIN core.team_kenpom_stats kps ON kps.team_id = tt.id AND kps.deleted_at IS NULL
LEFT JOIN core.schools s ON tt.school_id = s.id
WHERE tt.id = $1 AND tt.deleted_at IS NULL
`

type GetTournamentTeamByIDRow struct {
	ID           string
	TournamentID string
	SchoolID     string
	Seed         int32
	Region       string
	Byes         int32
	Wins         int32
	Eliminated   bool
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	NetRtg       *float64
	ORtg         *float64
	DRtg         *float64
	AdjT         *float64
	SchoolName   *string
}

func (q *Queries) GetTournamentTeamByID(ctx context.Context, id string) (GetTournamentTeamByIDRow, error) {
	row := q.db.QueryRow(ctx, getTournamentTeamByID, id)
	var i GetTournamentTeamByIDRow
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.SchoolID,
		&i.Seed,
		&i.Region,
		&i.Byes,
		&i.Wins,
		&i.Eliminated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NetRtg,
		&i.ORtg,
		&i.DRtg,
		&i.AdjT,
		&i.SchoolName,
	)
	return i, err
}

const getTournamentTeamsByTournamentID = `-- name: GetTournamentTeamsByTournamentID :many
SELECT
  tt.id,
  tt.tournament_id,
  tt.school_id,
  tt.seed,
  tt.region,
  tt.byes,
  tt.wins,
  tt.eliminated,
  tt.created_at,
  tt.updated_at,
  kps.net_rtg,
  kps.o_rtg,
  kps.d_rtg,
  kps.adj_t,
  s.name AS school_name
FROM core.teams tt
LEFT JOIN core.team_kenpom_stats kps ON kps.team_id = tt.id AND kps.deleted_at IS NULL
LEFT JOIN core.schools s ON tt.school_id = s.id
WHERE tt.tournament_id = $1 AND tt.deleted_at IS NULL
ORDER BY tt.seed ASC
`

type GetTournamentTeamsByTournamentIDRow struct {
	ID           string
	TournamentID string
	SchoolID     string
	Seed         int32
	Region       string
	Byes         int32
	Wins         int32
	Eliminated   bool
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	NetRtg       *float64
	ORtg         *float64
	DRtg         *float64
	AdjT         *float64
	SchoolName   *string
}

func (q *Queries) GetTournamentTeamsByTournamentID(ctx context.Context, tournamentID string) ([]GetTournamentTeamsByTournamentIDRow, error) {
	rows, err := q.db.Query(ctx, getTournamentTeamsByTournamentID, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTournamentTeamsByTournamentIDRow
	for rows.Next() {
		var i GetTournamentTeamsByTournamentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.TournamentID,
			&i.SchoolID,
			&i.Seed,
			&i.Region,
			&i.Byes,
			&i.Wins,
			&i.Eliminated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NetRtg,
			&i.ORtg,
			&i.DRtg,
			&i.AdjT,
			&i.SchoolName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentWinningTeam = `-- name: GetTournamentWinningTeam :one
SELECT
  tt.id,
  tt.tournament_id,
  tt.school_id,
  tt.seed,
  tt.region,
  tt.byes,
  tt.wins,
  tt.eliminated,
  tt.created_at,
  tt.updated_at,
  kps.net_rtg,
  kps.o_rtg,
  kps.d_rtg,
  kps.adj_t
FROM core.teams tt
LEFT JOIN core.team_kenpom_stats kps ON kps.team_id = tt.id AND kps.deleted_at IS NULL
WHERE tt.tournament_id = $1 AND tt.deleted_at IS NULL
ORDER BY tt.wins DESC
LIMIT 1
`

type GetTournamentWinningTeamRow struct {
	ID           string
	TournamentID string
	SchoolID     string
	Seed         int32
	Region       string
	Byes         int32
	Wins         int32
	Eliminated   bool
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	NetRtg       *float64
	ORtg         *float64
	DRtg         *float64
	AdjT         *float64
}

func (q *Queries) GetTournamentWinningTeam(ctx context.Context, tournamentID string) (GetTournamentWinningTeamRow, error) {
	row := q.db.QueryRow(ctx, getTournamentWinningTeam, tournamentID)
	var i GetTournamentWinningTeamRow
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.SchoolID,
		&i.Seed,
		&i.Region,
		&i.Byes,
		&i.Wins,
		&i.Eliminated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NetRtg,
		&i.ORtg,
		&i.DRtg,
		&i.AdjT,
	)
	return i, err
}

const updateTournamentTeam = `-- name: UpdateTournamentTeam :exec
UPDATE core.teams
SET wins = $1,
    byes = $2,
    eliminated = $3,
    updated_at = NOW()
WHERE id = $4 AND deleted_at IS NULL
`

type UpdateTournamentTeamParams struct {
	Wins       int32
	Byes       int32
	Eliminated bool
	ID         string
}

func (q *Queries) UpdateTournamentTeam(ctx context.Context, arg UpdateTournamentTeamParams) error {
	_, err := q.db.Exec(ctx, updateTournamentTeam,
		arg.Wins,
		arg.Byes,
		arg.Eliminated,
		arg.ID,
	)
	return err
}
