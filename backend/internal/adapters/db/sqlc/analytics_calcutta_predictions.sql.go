// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: analytics_calcutta_predictions.sql

package sqlc

import (
	"context"
)

const getCalcuttaPredictedInvestment = `-- name: GetCalcuttaPredictedInvestment :many
WITH calcutta_ctx AS (
  SELECT
    c.id AS calcutta_id,
    t.id AS core_tournament_id,
    seas.year AS year
  FROM core.calcuttas c
  JOIN core.tournaments t ON t.id = c.tournament_id AND t.deleted_at IS NULL
  JOIN core.seasons seas ON seas.id = t.season_id
  WHERE c.id = $1::uuid
    AND c.deleted_at IS NULL
  LIMIT 1
),
lab_tournament AS (
  SELECT bt.id AS tournament_id
  FROM lab_bronze.tournaments bt
  JOIN calcutta_ctx cc ON cc.core_tournament_id = bt.core_tournament_id
  LIMIT 1
),
entry_count AS (
  SELECT COUNT(*)::int AS num_entries
  FROM core.entries ce
  JOIN calcutta_ctx cc ON cc.calcutta_id = ce.calcutta_id
  WHERE ce.deleted_at IS NULL
),
total_pool AS (
  SELECT (COALESCE(NULLIF((SELECT num_entries FROM entry_count), 0), 47)::double precision * 100.0::double precision)::double precision AS pool_size
),
team_expected_points AS (
  SELECT
    st.team_id,
    AVG(core.calcutta_points_for_progress((SELECT calcutta_id FROM calcutta_ctx), st.wins + 1, st.byes))::float AS expected_points
  FROM derived.simulated_teams st
  WHERE st.tournament_id = (SELECT tournament_id FROM lab_tournament)
  GROUP BY st.team_id
),
total_expected_points AS (
  SELECT SUM(expected_points) AS total_ev
  FROM team_expected_points
)
SELECT
  t.id as team_id,
  t.school_name,
  COALESCE(t.seed, 0)::int as seed,
  COALESCE(t.region, '')::text as region,
  ((COALESCE(tep.expected_points, 0.0)::double precision / NULLIF((SELECT total_ev FROM total_expected_points)::double precision, 0.0::double precision)) * (SELECT pool_size FROM total_pool))::double precision as rational,
  (COALESCE(spms_t.predicted_share, 0.0)::double precision * (SELECT pool_size FROM total_pool))::double precision as predicted,
  CASE
    WHEN (COALESCE(tep.expected_points, 0.0) / NULLIF((SELECT total_ev FROM total_expected_points), 0)) * (SELECT pool_size FROM total_pool) > 0
    THEN ((COALESCE(spms_t.predicted_share, 0.0) * (SELECT pool_size FROM total_pool)) -
      ((COALESCE(tep.expected_points, 0.0) / NULLIF((SELECT total_ev FROM total_expected_points), 0)) * (SELECT pool_size FROM total_pool))) /
      ((COALESCE(tep.expected_points, 0.0) / NULLIF((SELECT total_ev FROM total_expected_points), 0)) * (SELECT pool_size FROM total_pool)) * 100
    ELSE 0
  END::double precision as delta
FROM lab_bronze.teams t
LEFT JOIN team_expected_points tep ON t.id = tep.team_id
LEFT JOIN lab_silver.predicted_market_share spms_t
  ON spms_t.tournament_id = (SELECT tournament_id FROM lab_tournament)
  AND spms_t.calcutta_id IS NULL
  AND spms_t.team_id = t.id
WHERE t.tournament_id = (SELECT tournament_id FROM lab_tournament)
ORDER BY predicted DESC, seed ASC
`

type GetCalcuttaPredictedInvestmentRow struct {
	TeamID     string
	SchoolName string
	Seed       int32
	Region     string
	Rational   float64
	Predicted  float64
	Delta      float64
}

func (q *Queries) GetCalcuttaPredictedInvestment(ctx context.Context, calcuttaID string) ([]GetCalcuttaPredictedInvestmentRow, error) {
	rows, err := q.db.Query(ctx, getCalcuttaPredictedInvestment, calcuttaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCalcuttaPredictedInvestmentRow
	for rows.Next() {
		var i GetCalcuttaPredictedInvestmentRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.Rational,
			&i.Predicted,
			&i.Delta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCalcuttaPredictedInvestmentByStrategyGenerationRunID = `-- name: GetCalcuttaPredictedInvestmentByStrategyGenerationRunID :many
WITH strategy_run AS (
  SELECT
    sgr.simulated_tournament_id
  FROM lab_gold.strategy_generation_runs sgr
  WHERE sgr.id = $1::uuid
    AND sgr.deleted_at IS NULL
  LIMIT 1
),
calcutta_ctx AS (
  SELECT
    c.id AS calcutta_id,
    t.id AS core_tournament_id,
    seas.year AS year
  FROM core.calcuttas c
  JOIN core.tournaments t ON t.id = c.tournament_id AND t.deleted_at IS NULL
  JOIN core.seasons seas ON seas.id = t.season_id
  WHERE c.id = $2::uuid
    AND c.deleted_at IS NULL
  LIMIT 1
),
lab_tournament AS (
  SELECT bt.id AS tournament_id
  FROM lab_bronze.tournaments bt
  JOIN calcutta_ctx cc ON cc.core_tournament_id = bt.core_tournament_id
  LIMIT 1
),
entry_count AS (
  SELECT COUNT(*)::int AS num_entries
  FROM core.entries ce
  JOIN calcutta_ctx cc ON cc.calcutta_id = ce.calcutta_id
  WHERE ce.deleted_at IS NULL
),
total_pool AS (
  SELECT (COALESCE(NULLIF((SELECT num_entries FROM entry_count), 0), 47)::double precision * 100.0::double precision)::double precision AS pool_size
),
team_expected_points AS (
  SELECT
    st.team_id,
    AVG(core.calcutta_points_for_progress((SELECT calcutta_id FROM calcutta_ctx), st.wins + 1, st.byes))::float AS expected_points
  FROM derived.simulated_teams st
  WHERE st.tournament_id = (SELECT tournament_id FROM lab_tournament)
    AND st.simulated_tournament_id = (SELECT simulated_tournament_id FROM strategy_run)
  GROUP BY st.team_id
),
total_expected_points AS (
  SELECT SUM(expected_points) AS total_ev
  FROM team_expected_points
)
SELECT
  t.id as team_id,
  t.school_name,
  COALESCE(t.seed, 0)::int as seed,
  COALESCE(t.region, '')::text as region,
  ((COALESCE(tep.expected_points, 0.0)::double precision / NULLIF((SELECT total_ev FROM total_expected_points)::double precision, 0.0::double precision)) * (SELECT pool_size FROM total_pool))::double precision as rational,
  (COALESCE(spms_t.predicted_share, 0.0)::double precision * (SELECT pool_size FROM total_pool))::double precision as predicted,
  CASE
    WHEN (COALESCE(tep.expected_points, 0.0) / NULLIF((SELECT total_ev FROM total_expected_points), 0)) * (SELECT pool_size FROM total_pool) > 0
    THEN ((COALESCE(spms_t.predicted_share, 0.0) * (SELECT pool_size FROM total_pool)) -
      ((COALESCE(tep.expected_points, 0.0) / NULLIF((SELECT total_ev FROM total_expected_points), 0)) * (SELECT pool_size FROM total_pool))) /
      ((COALESCE(tep.expected_points, 0.0) / NULLIF((SELECT total_ev FROM total_expected_points), 0)) * (SELECT pool_size FROM total_pool)) * 100
    ELSE 0
  END::double precision as delta
FROM lab_bronze.teams t
LEFT JOIN team_expected_points tep ON t.id = tep.team_id
LEFT JOIN lab_silver.predicted_market_share spms_t
  ON spms_t.tournament_id = (SELECT tournament_id FROM lab_tournament)
  AND spms_t.calcutta_id IS NULL
  AND spms_t.team_id = t.id
WHERE t.tournament_id = (SELECT tournament_id FROM lab_tournament)
ORDER BY predicted DESC, seed ASC
`

type GetCalcuttaPredictedInvestmentByStrategyGenerationRunIDParams struct {
	StrategyGenerationRunID string
	CalcuttaID              string
}

type GetCalcuttaPredictedInvestmentByStrategyGenerationRunIDRow struct {
	TeamID     string
	SchoolName string
	Seed       int32
	Region     string
	Rational   float64
	Predicted  float64
	Delta      float64
}

func (q *Queries) GetCalcuttaPredictedInvestmentByStrategyGenerationRunID(ctx context.Context, arg GetCalcuttaPredictedInvestmentByStrategyGenerationRunIDParams) ([]GetCalcuttaPredictedInvestmentByStrategyGenerationRunIDRow, error) {
	rows, err := q.db.Query(ctx, getCalcuttaPredictedInvestmentByStrategyGenerationRunID, arg.StrategyGenerationRunID, arg.CalcuttaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCalcuttaPredictedInvestmentByStrategyGenerationRunIDRow
	for rows.Next() {
		var i GetCalcuttaPredictedInvestmentByStrategyGenerationRunIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.Rational,
			&i.Predicted,
			&i.Delta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCalcuttaPredictedReturns = `-- name: GetCalcuttaPredictedReturns :many
WITH calcutta_ctx AS (
  SELECT
    c.id AS calcutta_id,
    t.id AS core_tournament_id
  FROM core.calcuttas c
  JOIN core.tournaments t ON t.id = c.tournament_id AND t.deleted_at IS NULL
  WHERE c.id = $1::uuid
    AND c.deleted_at IS NULL
  LIMIT 1
),
lab_tournament AS (
  SELECT bt.id AS tournament_id
  FROM lab_bronze.tournaments bt
  JOIN calcutta_ctx cc ON cc.core_tournament_id = bt.core_tournament_id
  LIMIT 1
),
team_win_counts AS (
  SELECT
    st.team_id,
    (st.wins + st.byes + 1)::int AS progress,
    COUNT(*) as sim_count
  FROM derived.simulated_teams st
  WHERE st.tournament_id = (SELECT tournament_id FROM lab_tournament)
  GROUP BY st.team_id, progress
),
team_probabilities AS (
  SELECT
    team_id,
    SUM(sim_count)::float as total_sims,
    SUM(CASE WHEN progress >= 2 THEN sim_count ELSE 0 END)::float as win_r64,
    SUM(CASE WHEN progress >= 3 THEN sim_count ELSE 0 END)::float as win_r32,
    SUM(CASE WHEN progress >= 4 THEN sim_count ELSE 0 END)::float as win_s16,
    SUM(CASE WHEN progress >= 5 THEN sim_count ELSE 0 END)::float as win_e8,
    SUM(CASE WHEN progress >= 6 THEN sim_count ELSE 0 END)::float as win_ff,
    SUM(CASE WHEN progress >= 7 THEN sim_count ELSE 0 END)::float as win_champ
  FROM team_win_counts
  GROUP BY team_id
),
team_expected_value AS (
  SELECT
    st.team_id,
    AVG(core.calcutta_points_for_progress((SELECT calcutta_id FROM calcutta_ctx), st.wins + 1, st.byes))::float AS expected_value
  FROM derived.simulated_teams st
  WHERE st.tournament_id = (SELECT tournament_id FROM lab_tournament)
  GROUP BY st.team_id
)
SELECT
  t.id as team_id,
  t.school_name,
  COALESCE(t.seed, 0)::int as seed,
  COALESCE(t.region, '')::text as region,
  0.0::double precision as prob_pi,
  COALESCE(tp.win_r64 / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_r64,
  COALESCE(tp.win_r32 / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_r32,
  COALESCE(tp.win_s16 / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_s16,
  COALESCE(tp.win_e8 / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_e8,
  COALESCE(tp.win_ff / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_ff,
  COALESCE(tp.win_champ / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_champ,
  COALESCE(tev.expected_value, 0.0)::double precision as expected_value
FROM lab_bronze.teams t
LEFT JOIN team_probabilities tp ON t.id = tp.team_id
LEFT JOIN team_expected_value tev ON t.id = tev.team_id
WHERE t.tournament_id = (SELECT tournament_id FROM lab_tournament)
ORDER BY expected_value DESC, seed ASC
`

type GetCalcuttaPredictedReturnsRow struct {
	TeamID        string
	SchoolName    string
	Seed          int32
	Region        string
	ProbPi        float64
	ProbR64       float64
	ProbR32       float64
	ProbS16       float64
	ProbE8        float64
	ProbFf        float64
	ProbChamp     float64
	ExpectedValue float64
}

func (q *Queries) GetCalcuttaPredictedReturns(ctx context.Context, calcuttaID string) ([]GetCalcuttaPredictedReturnsRow, error) {
	rows, err := q.db.Query(ctx, getCalcuttaPredictedReturns, calcuttaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCalcuttaPredictedReturnsRow
	for rows.Next() {
		var i GetCalcuttaPredictedReturnsRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.ProbPi,
			&i.ProbR64,
			&i.ProbR32,
			&i.ProbS16,
			&i.ProbE8,
			&i.ProbFf,
			&i.ProbChamp,
			&i.ExpectedValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCalcuttaPredictedReturnsByStrategyGenerationRunID = `-- name: GetCalcuttaPredictedReturnsByStrategyGenerationRunID :many
WITH strategy_run AS (
  SELECT
    sgr.simulated_tournament_id
  FROM lab_gold.strategy_generation_runs sgr
  WHERE sgr.id = $1::uuid
    AND sgr.deleted_at IS NULL
  LIMIT 1
),
calcutta_ctx AS (
  SELECT
    c.id AS calcutta_id,
    t.id AS core_tournament_id
  FROM core.calcuttas c
  JOIN core.tournaments t ON t.id = c.tournament_id AND t.deleted_at IS NULL
  WHERE c.id = $2::uuid
    AND c.deleted_at IS NULL
  LIMIT 1
),
lab_tournament AS (
  SELECT bt.id AS tournament_id
  FROM lab_bronze.tournaments bt
  JOIN calcutta_ctx cc ON cc.core_tournament_id = bt.core_tournament_id
  LIMIT 1
),
team_win_counts AS (
  SELECT
    st.team_id,
    (st.wins + st.byes + 1)::int AS progress,
    COUNT(*) as sim_count
  FROM derived.simulated_teams st
  WHERE st.tournament_id = (SELECT tournament_id FROM lab_tournament)
    AND st.simulated_tournament_id = (SELECT simulated_tournament_id FROM strategy_run)
  GROUP BY st.team_id, progress
),
team_probabilities AS (
  SELECT
    team_id,
    SUM(sim_count)::float as total_sims,
    SUM(CASE WHEN progress >= 2 THEN sim_count ELSE 0 END)::float as win_r64,
    SUM(CASE WHEN progress >= 3 THEN sim_count ELSE 0 END)::float as win_r32,
    SUM(CASE WHEN progress >= 4 THEN sim_count ELSE 0 END)::float as win_s16,
    SUM(CASE WHEN progress >= 5 THEN sim_count ELSE 0 END)::float as win_e8,
    SUM(CASE WHEN progress >= 6 THEN sim_count ELSE 0 END)::float as win_ff,
    SUM(CASE WHEN progress >= 7 THEN sim_count ELSE 0 END)::float as win_champ
  FROM team_win_counts
  GROUP BY team_id
),
team_expected_value AS (
  SELECT
    st.team_id,
    AVG(core.calcutta_points_for_progress((SELECT calcutta_id FROM calcutta_ctx), st.wins + 1, st.byes))::float AS expected_value
  FROM derived.simulated_teams st
  WHERE st.tournament_id = (SELECT tournament_id FROM lab_tournament)
    AND st.simulated_tournament_id = (SELECT simulated_tournament_id FROM strategy_run)
  GROUP BY st.team_id
)
SELECT
  t.id as team_id,
  t.school_name,
  COALESCE(t.seed, 0)::int as seed,
  COALESCE(t.region, '')::text as region,
  0.0::double precision as prob_pi,
  COALESCE(tp.win_r64 / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_r64,
  COALESCE(tp.win_r32 / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_r32,
  COALESCE(tp.win_s16 / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_s16,
  COALESCE(tp.win_e8 / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_e8,
  COALESCE(tp.win_ff / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_ff,
  COALESCE(tp.win_champ / NULLIF(tp.total_sims, 0.0::double precision), 0.0::double precision)::double precision as prob_champ,
  COALESCE(tev.expected_value, 0.0)::double precision as expected_value
FROM lab_bronze.teams t
LEFT JOIN team_probabilities tp ON t.id = tp.team_id
LEFT JOIN team_expected_value tev ON t.id = tev.team_id
WHERE t.tournament_id = (SELECT tournament_id FROM lab_tournament)
ORDER BY expected_value DESC, seed ASC
`

type GetCalcuttaPredictedReturnsByStrategyGenerationRunIDParams struct {
	StrategyGenerationRunID string
	CalcuttaID              string
}

type GetCalcuttaPredictedReturnsByStrategyGenerationRunIDRow struct {
	TeamID        string
	SchoolName    string
	Seed          int32
	Region        string
	ProbPi        float64
	ProbR64       float64
	ProbR32       float64
	ProbS16       float64
	ProbE8        float64
	ProbFf        float64
	ProbChamp     float64
	ExpectedValue float64
}

func (q *Queries) GetCalcuttaPredictedReturnsByStrategyGenerationRunID(ctx context.Context, arg GetCalcuttaPredictedReturnsByStrategyGenerationRunIDParams) ([]GetCalcuttaPredictedReturnsByStrategyGenerationRunIDRow, error) {
	rows, err := q.db.Query(ctx, getCalcuttaPredictedReturnsByStrategyGenerationRunID, arg.StrategyGenerationRunID, arg.CalcuttaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCalcuttaPredictedReturnsByStrategyGenerationRunIDRow
	for rows.Next() {
		var i GetCalcuttaPredictedReturnsByStrategyGenerationRunIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.ProbPi,
			&i.ProbR64,
			&i.ProbR32,
			&i.ProbS16,
			&i.ProbE8,
			&i.ProbFf,
			&i.ProbChamp,
			&i.ExpectedValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCalcuttaSimulatedEntry = `-- name: GetCalcuttaSimulatedEntry :many
WITH calcutta_ctx AS (
  SELECT
    c.id AS calcutta_id,
    c.budget_points,
    t.id AS core_tournament_id,
    seas.year AS year
  FROM core.calcuttas c
  JOIN core.tournaments t ON t.id = c.tournament_id AND t.deleted_at IS NULL
  JOIN core.seasons seas ON seas.id = t.season_id
  WHERE c.id = $1::uuid
    AND c.deleted_at IS NULL
  LIMIT 1
),
lab_tournament AS (
  SELECT bt.id AS tournament_id
  FROM lab_bronze.tournaments bt
  JOIN calcutta_ctx cc ON cc.core_tournament_id = bt.core_tournament_id
  LIMIT 1
),
entry_count AS (
  SELECT COUNT(*)::int AS num_entries
  FROM core.entries ce
  JOIN calcutta_ctx cc ON cc.calcutta_id = ce.calcutta_id
  WHERE ce.deleted_at IS NULL
),
total_pool AS (
  SELECT COALESCE(NULLIF((SELECT num_entries FROM entry_count), 0), 47)
    * COALESCE((SELECT budget_points FROM calcutta_ctx), 100)::double precision AS pool_size
),
team_expected_points AS (
  SELECT
    st.team_id,
    AVG(core.calcutta_points_for_progress((SELECT calcutta_id FROM calcutta_ctx), st.wins + 1, st.byes))::float AS expected_points
  FROM derived.simulated_teams st
  WHERE st.tournament_id = (SELECT tournament_id FROM lab_tournament)
  GROUP BY st.team_id
),
latest_strategy_generation AS (
  SELECT sgr.id AS strategy_generation_run_id
  FROM lab_gold.strategy_generation_runs sgr
  JOIN calcutta_ctx cc ON TRUE
  WHERE sgr.deleted_at IS NULL
    AND sgr.calcutta_id = cc.calcutta_id
  ORDER BY sgr.created_at DESC
  LIMIT 1
)
SELECT
  t.id as team_id,
  t.school_name,
  COALESCE(t.seed, 0)::int as seed,
  COALESCE(t.region, '')::text as region,
  COALESCE(tep.expected_points, 0.0)::double precision as expected_points,
  (COALESCE(spms_t.predicted_share, 0.0)::double precision * (SELECT pool_size FROM total_pool))::double precision as expected_market,
  COALESCE(reb.recommended_bid_points, 0.0)::double precision as our_bid
FROM lab_bronze.teams t
LEFT JOIN team_expected_points tep ON t.id = tep.team_id
LEFT JOIN lab_silver.predicted_market_share spms_t
  ON spms_t.tournament_id = (SELECT tournament_id FROM lab_tournament)
  AND spms_t.calcutta_id IS NULL
  AND spms_t.team_id = t.id
LEFT JOIN latest_strategy_generation lsg ON true
LEFT JOIN lab_gold.recommended_entry_bids reb
  ON reb.strategy_generation_run_id = lsg.strategy_generation_run_id
  AND reb.team_id = t.id
WHERE t.tournament_id = (SELECT tournament_id FROM lab_tournament)
ORDER BY seed ASC, t.school_name ASC
`

type GetCalcuttaSimulatedEntryRow struct {
	TeamID         string
	SchoolName     string
	Seed           int32
	Region         string
	ExpectedPoints float64
	ExpectedMarket float64
	OurBid         float64
}

func (q *Queries) GetCalcuttaSimulatedEntry(ctx context.Context, dollar_1 string) ([]GetCalcuttaSimulatedEntryRow, error) {
	rows, err := q.db.Query(ctx, getCalcuttaSimulatedEntry, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCalcuttaSimulatedEntryRow
	for rows.Next() {
		var i GetCalcuttaSimulatedEntryRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.ExpectedPoints,
			&i.ExpectedMarket,
			&i.OurBid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCalcuttaSimulatedEntryByStrategyGenerationRunID = `-- name: GetCalcuttaSimulatedEntryByStrategyGenerationRunID :many
WITH calcutta_ctx AS (
  SELECT
    c.id AS calcutta_id,
    c.budget_points,
    t.id AS core_tournament_id
  FROM core.calcuttas c
  JOIN core.tournaments t ON t.id = c.tournament_id AND t.deleted_at IS NULL
  WHERE c.id = $2::uuid
    AND c.deleted_at IS NULL
  LIMIT 1
),
lab_tournament AS (
  SELECT bt.id AS tournament_id
  FROM lab_bronze.tournaments bt
  JOIN calcutta_ctx cc ON cc.core_tournament_id = bt.core_tournament_id
  LIMIT 1
),
entry_count AS (
  SELECT COUNT(*)::int AS num_entries
  FROM core.entries ce
  JOIN calcutta_ctx cc ON cc.calcutta_id = ce.calcutta_id
  WHERE ce.deleted_at IS NULL
),
total_pool AS (
  SELECT COALESCE(NULLIF((SELECT num_entries FROM entry_count), 0), 47)
    * COALESCE((SELECT budget_points FROM calcutta_ctx), 100)::double precision AS pool_size
),
team_expected_points AS (
  SELECT
    st.team_id,
    AVG(core.calcutta_points_for_progress((SELECT calcutta_id FROM calcutta_ctx), st.wins + 1, st.byes))::float AS expected_points
  FROM derived.simulated_teams st
  WHERE st.tournament_id = (SELECT tournament_id FROM lab_tournament)
  GROUP BY st.team_id
)
SELECT
  t.id as team_id,
  t.school_name,
  COALESCE(t.seed, 0)::int as seed,
  COALESCE(t.region, '')::text as region,
  COALESCE(tep.expected_points, 0.0)::double precision as expected_points,
  (COALESCE(spms_t.predicted_share, 0.0)::double precision * (SELECT pool_size FROM total_pool))::double precision as expected_market,
  COALESCE(reb.recommended_bid_points, 0.0)::double precision as our_bid
FROM lab_bronze.teams t
LEFT JOIN team_expected_points tep ON t.id = tep.team_id
LEFT JOIN lab_silver.predicted_market_share spms_t
  ON spms_t.tournament_id = (SELECT tournament_id FROM lab_tournament)
  AND spms_t.calcutta_id IS NULL
  AND spms_t.team_id = t.id
LEFT JOIN lab_gold.recommended_entry_bids reb
  ON reb.strategy_generation_run_id = $1::uuid
  AND reb.team_id = t.id
WHERE t.tournament_id = (SELECT tournament_id FROM lab_tournament)
ORDER BY seed ASC, t.school_name ASC
`

type GetCalcuttaSimulatedEntryByStrategyGenerationRunIDParams struct {
	StrategyGenerationRunID string
	CalcuttaID              string
}

type GetCalcuttaSimulatedEntryByStrategyGenerationRunIDRow struct {
	TeamID         string
	SchoolName     string
	Seed           int32
	Region         string
	ExpectedPoints float64
	ExpectedMarket float64
	OurBid         float64
}

func (q *Queries) GetCalcuttaSimulatedEntryByStrategyGenerationRunID(ctx context.Context, arg GetCalcuttaSimulatedEntryByStrategyGenerationRunIDParams) ([]GetCalcuttaSimulatedEntryByStrategyGenerationRunIDRow, error) {
	rows, err := q.db.Query(ctx, getCalcuttaSimulatedEntryByStrategyGenerationRunID, arg.StrategyGenerationRunID, arg.CalcuttaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCalcuttaSimulatedEntryByStrategyGenerationRunIDRow
	for rows.Next() {
		var i GetCalcuttaSimulatedEntryByStrategyGenerationRunIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.ExpectedPoints,
			&i.ExpectedMarket,
			&i.OurBid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestStrategyGenerationRunIDByCoreCalcuttaID = `-- name: GetLatestStrategyGenerationRunIDByCoreCalcuttaID :one
SELECT
	sgr.id
FROM lab_gold.strategy_generation_runs sgr
WHERE sgr.calcutta_id = $1::uuid
	AND sgr.deleted_at IS NULL
ORDER BY sgr.created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestStrategyGenerationRunIDByCoreCalcuttaID(ctx context.Context, calcuttaID string) (string, error) {
	row := q.db.QueryRow(ctx, getLatestStrategyGenerationRunIDByCoreCalcuttaID, calcuttaID)
	var id string
	err := row.Scan(&id)
	return id, err
}
