// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ml_analytics_portfolios.sql

package sqlc

import (
	"context"
)

const getActualEntryPortfolio = `-- name: GetActualEntryPortfolio :many
WITH optimized_entry AS (
	SELECT oe.calcutta_id
	FROM derived.optimized_entries oe
	WHERE oe.run_key = $2::text
		AND oe.deleted_at IS NULL
	LIMIT 1
)
SELECT
    t.id as team_id,
    s.name as school_name,
    t.seed,
    t.region,
    eb.bid_points
FROM derived.entry_bids eb
JOIN optimized_entry oe ON oe.calcutta_id = eb.calcutta_id
JOIN core.teams t ON eb.team_id = t.id AND t.deleted_at IS NULL
JOIN core.schools s ON s.id = t.school_id AND s.deleted_at IS NULL
WHERE eb.entry_name = $1
    AND eb.deleted_at IS NULL
ORDER BY eb.bid_points DESC
`

type GetActualEntryPortfolioParams struct {
	EntryName string
	RunID     string
}

type GetActualEntryPortfolioRow struct {
	TeamID     string
	SchoolName string
	Seed       int32
	Region     string
	BidPoints  int32
}

// For actual entries from the auction
func (q *Queries) GetActualEntryPortfolio(ctx context.Context, arg GetActualEntryPortfolioParams) ([]GetActualEntryPortfolioRow, error) {
	rows, err := q.db.Query(ctx, getActualEntryPortfolio, arg.EntryName, arg.RunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActualEntryPortfolioRow
	for rows.Next() {
		var i GetActualEntryPortfolioRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryPortfolio = `-- name: GetEntryPortfolio :many
SELECT
    t.id as team_id,
    s.name as school_name,
    t.seed,
    t.region,
    (bid->>'bid_points')::int as bid_points
FROM derived.optimized_entries oe,
     jsonb_array_elements(oe.bids_json) AS bid
JOIN core.teams t ON (bid->>'team_id')::uuid = t.id AND t.deleted_at IS NULL
JOIN core.schools s ON s.id = t.school_id AND s.deleted_at IS NULL
WHERE oe.run_key = $1
    AND oe.deleted_at IS NULL
ORDER BY (bid->>'bid_points')::int DESC
`

type GetEntryPortfolioRow struct {
	TeamID     string
	SchoolName string
	Seed       int32
	Region     string
	BidPoints  int32
}

// For our strategy entry
func (q *Queries) GetEntryPortfolio(ctx context.Context, runID *string) ([]GetEntryPortfolioRow, error) {
	rows, err := q.db.Query(ctx, getEntryPortfolio, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryPortfolioRow
	for rows.Next() {
		var i GetEntryPortfolioRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryPortfolioByOptimizedEntryID = `-- name: GetEntryPortfolioByOptimizedEntryID :many
SELECT
	t.id as team_id,
	s.name as school_name,
	t.seed,
	t.region,
	(bid->>'bid_points')::int as bid_points
FROM derived.optimized_entries oe,
     jsonb_array_elements(oe.bids_json) AS bid
JOIN core.teams t ON (bid->>'team_id')::uuid = t.id AND t.deleted_at IS NULL
JOIN core.schools s ON s.id = t.school_id AND s.deleted_at IS NULL
WHERE oe.id = $1::uuid
    AND oe.deleted_at IS NULL
ORDER BY (bid->>'bid_points')::int DESC
`

type GetEntryPortfolioByOptimizedEntryIDRow struct {
	TeamID     string
	SchoolName string
	Seed       int32
	Region     string
	BidPoints  int32
}

// For our strategy entry (lineage-native)
func (q *Queries) GetEntryPortfolioByOptimizedEntryID(ctx context.Context, optimizedEntryID string) ([]GetEntryPortfolioByOptimizedEntryIDRow, error) {
	rows, err := q.db.Query(ctx, getEntryPortfolioByOptimizedEntryID, optimizedEntryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryPortfolioByOptimizedEntryIDRow
	for rows.Next() {
		var i GetEntryPortfolioByOptimizedEntryIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOurEntryBidsByOptimizedEntryID = `-- name: GetOurEntryBidsByOptimizedEntryID :many
SELECT
	t.id as team_id,
	s.name as school_name,
	t.seed,
	t.region,
	(bid->>'bid_points')::int as bid_points,
	COALESCE((bid->>'expected_roi')::double precision, 0) as expected_roi
FROM derived.optimized_entries oe,
     jsonb_array_elements(oe.bids_json) AS bid
JOIN core.teams t ON t.id = (bid->>'team_id')::uuid AND t.deleted_at IS NULL
JOIN core.schools s ON s.id = t.school_id AND s.deleted_at IS NULL
WHERE oe.id = $1::uuid
    AND oe.deleted_at IS NULL
ORDER BY (bid->>'bid_points')::int DESC
`

type GetOurEntryBidsByOptimizedEntryIDRow struct {
	TeamID      string
	SchoolName  string
	Seed        int32
	Region      string
	BidPoints   int32
	ExpectedRoi interface{}
}

func (q *Queries) GetOurEntryBidsByOptimizedEntryID(ctx context.Context, dollar_1 string) ([]GetOurEntryBidsByOptimizedEntryIDRow, error) {
	rows, err := q.db.Query(ctx, getOurEntryBidsByOptimizedEntryID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOurEntryBidsByOptimizedEntryIDRow
	for rows.Next() {
		var i GetOurEntryBidsByOptimizedEntryIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidPoints,
			&i.ExpectedRoi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOurEntryBidsByRunID = `-- name: GetOurEntryBidsByRunID :many
SELECT
    t.id as team_id,
    s.name as school_name,
    t.seed,
    t.region,
    (bid->>'bid_points')::int as bid_points,
    COALESCE((bid->>'expected_roi')::double precision, 0) as expected_roi
FROM derived.optimized_entries oe,
     jsonb_array_elements(oe.bids_json) AS bid
JOIN core.teams t ON t.id = (bid->>'team_id')::uuid AND t.deleted_at IS NULL
JOIN core.schools s ON s.id = t.school_id AND s.deleted_at IS NULL
WHERE oe.run_key = $1::text
    AND oe.deleted_at IS NULL
ORDER BY (bid->>'bid_points')::int DESC
`

type GetOurEntryBidsByRunIDRow struct {
	TeamID      string
	SchoolName  string
	Seed        int32
	Region      string
	BidPoints   int32
	ExpectedRoi interface{}
}

func (q *Queries) GetOurEntryBidsByRunID(ctx context.Context, dollar_1 string) ([]GetOurEntryBidsByRunIDRow, error) {
	rows, err := q.db.Query(ctx, getOurEntryBidsByRunID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOurEntryBidsByRunIDRow
	for rows.Next() {
		var i GetOurEntryBidsByRunIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidPoints,
			&i.ExpectedRoi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
