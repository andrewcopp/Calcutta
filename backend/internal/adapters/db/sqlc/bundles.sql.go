// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: bundles.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimNextBundleUpload = `-- name: ClaimNextBundleUpload :one
WITH candidate AS (
	SELECT id
	FROM bundle_uploads
	WHERE deleted_at IS NULL
	  AND bundle_uploads.finished_at IS NULL
	  AND (
		bundle_uploads.status = 'pending'
		OR (bundle_uploads.status = 'running' AND bundle_uploads.started_at IS NOT NULL AND bundle_uploads.started_at < $2)
	  )
	ORDER BY created_at ASC
	LIMIT 1
	FOR UPDATE SKIP LOCKED
)
UPDATE bundle_uploads bu
SET status = 'running',
	started_at = $1,
	finished_at = NULL,
	error_message = NULL,
	import_report = NULL,
	verify_report = NULL,
	updated_at = NOW()
FROM candidate c
WHERE bu.id = c.id
RETURNING bu.id
`

type ClaimNextBundleUploadParams struct {
	Now         pgtype.Timestamptz
	StaleBefore pgtype.Timestamptz
}

func (q *Queries) ClaimNextBundleUpload(ctx context.Context, arg ClaimNextBundleUploadParams) (string, error) {
	row := q.db.QueryRow(ctx, claimNextBundleUpload, arg.Now, arg.StaleBefore)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getBundleUploadArchive = `-- name: GetBundleUploadArchive :one
SELECT archive
FROM bundle_uploads
WHERE id = $1::uuid AND deleted_at IS NULL
`

func (q *Queries) GetBundleUploadArchive(ctx context.Context, uploadID string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getBundleUploadArchive, uploadID)
	var archive []byte
	err := row.Scan(&archive)
	return archive, err
}

const getBundleUploadStatus = `-- name: GetBundleUploadStatus :one
SELECT
	filename,
	sha256,
	size_bytes,
	status,
	started_at,
	finished_at,
	error_message,
	COALESCE(import_report, '{}'::jsonb)::jsonb AS import_report,
	COALESCE(verify_report, '{}'::jsonb)::jsonb AS verify_report
FROM bundle_uploads
WHERE id = $1::uuid AND deleted_at IS NULL
`

type GetBundleUploadStatusRow struct {
	Filename     string
	Sha256       string
	SizeBytes    int64
	Status       string
	StartedAt    pgtype.Timestamptz
	FinishedAt   pgtype.Timestamptz
	ErrorMessage *string
	ImportReport []byte
	VerifyReport []byte
}

func (q *Queries) GetBundleUploadStatus(ctx context.Context, uploadID string) (GetBundleUploadStatusRow, error) {
	row := q.db.QueryRow(ctx, getBundleUploadStatus, uploadID)
	var i GetBundleUploadStatusRow
	err := row.Scan(
		&i.Filename,
		&i.Sha256,
		&i.SizeBytes,
		&i.Status,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ErrorMessage,
		&i.ImportReport,
		&i.VerifyReport,
	)
	return i, err
}

const markBundleUploadFailed = `-- name: MarkBundleUploadFailed :exec
UPDATE bundle_uploads
SET status = 'failed',
	finished_at = NOW(),
	error_message = $1,
	updated_at = NOW()
WHERE id = $2::uuid AND deleted_at IS NULL
`

type MarkBundleUploadFailedParams struct {
	ErrorMessage *string
	UploadID     string
}

func (q *Queries) MarkBundleUploadFailed(ctx context.Context, arg MarkBundleUploadFailedParams) error {
	_, err := q.db.Exec(ctx, markBundleUploadFailed, arg.ErrorMessage, arg.UploadID)
	return err
}

const markBundleUploadSucceeded = `-- name: MarkBundleUploadSucceeded :exec
UPDATE bundle_uploads
SET status = 'succeeded',
	finished_at = NOW(),
	import_report = $1,
	verify_report = $2,
	updated_at = NOW()
WHERE id = $3::uuid AND deleted_at IS NULL
`

type MarkBundleUploadSucceededParams struct {
	ImportReport []byte
	VerifyReport []byte
	UploadID     string
}

func (q *Queries) MarkBundleUploadSucceeded(ctx context.Context, arg MarkBundleUploadSucceededParams) error {
	_, err := q.db.Exec(ctx, markBundleUploadSucceeded, arg.ImportReport, arg.VerifyReport, arg.UploadID)
	return err
}

const upsertBundleUpload = `-- name: UpsertBundleUpload :one

INSERT INTO bundle_uploads (filename, sha256, size_bytes, archive, status)
VALUES ($1, $2, $3, $4, 'pending')
ON CONFLICT (sha256) WHERE deleted_at IS NULL
DO UPDATE SET
	filename = EXCLUDED.filename,
	size_bytes = EXCLUDED.size_bytes,
	archive = EXCLUDED.archive,
	status = 'pending',
	started_at = NULL,
	finished_at = NULL,
	error_message = NULL,
	import_report = NULL,
	verify_report = NULL,
	updated_at = NOW()
RETURNING id
`

type UpsertBundleUploadParams struct {
	Filename  string
	Sha256    string
	SizeBytes int64
	Archive   []byte
}

// Bundles / bundle uploads
func (q *Queries) UpsertBundleUpload(ctx context.Context, arg UpsertBundleUploadParams) (string, error) {
	row := q.db.QueryRow(ctx, upsertBundleUpload,
		arg.Filename,
		arg.Sha256,
		arg.SizeBytes,
		arg.Archive,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}
