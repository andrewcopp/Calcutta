// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ml_analytics_runs.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getOptimizedEntryByRunKey = `-- name: GetOptimizedEntryByRunKey :one
SELECT
	oe.id,
	COALESCE(oe.run_key, ''::text) AS run_id,
	COALESCE(NULLIF(oe.name, ''::text), COALESCE(oe.run_key, ''::text)) AS name,
	oe.calcutta_id,
	COALESCE(NULLIF(oe.optimizer_kind::text, ''::text), 'legacy'::text) AS strategy,
	COALESCE(tsb.n_sims, 0)::int AS n_sims,
	COALESCE(tsb.seed, 0)::int AS seed,
	COALESCE(c.budget_points, 100)::int AS budget_points,
	oe.created_at
FROM derived.optimized_entries oe
LEFT JOIN core.calcuttas c
	ON c.id = oe.calcutta_id
	AND c.deleted_at IS NULL
LEFT JOIN derived.simulated_tournaments tsb
	ON tsb.id = oe.simulated_tournament_id
	AND tsb.deleted_at IS NULL
WHERE oe.run_key = $1::text
	AND oe.deleted_at IS NULL
LIMIT 1
`

type GetOptimizedEntryByRunKeyRow struct {
	ID           string
	RunID        *string
	Name         interface{}
	CalcuttaID   string
	Strategy     interface{}
	NSims        int32
	Seed         int32
	BudgetPoints int32
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetOptimizedEntryByRunKey(ctx context.Context, dollar_1 string) (GetOptimizedEntryByRunKeyRow, error) {
	row := q.db.QueryRow(ctx, getOptimizedEntryByRunKey, dollar_1)
	var i GetOptimizedEntryByRunKeyRow
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.Name,
		&i.CalcuttaID,
		&i.Strategy,
		&i.NSims,
		&i.Seed,
		&i.BudgetPoints,
		&i.CreatedAt,
	)
	return i, err
}

const listCalcuttaEvaluationRunsByCoreCalcuttaID = `-- name: ListCalcuttaEvaluationRunsByCoreCalcuttaID :many
SELECT
	cer.id,
	cer.simulated_tournament_id,
	cer.calcutta_snapshot_id,
	cer.purpose,
	cer.created_at
FROM derived.calcutta_evaluation_runs cer
JOIN core.calcutta_snapshots cs
	ON cs.id = cer.calcutta_snapshot_id
	AND cs.deleted_at IS NULL
WHERE cs.base_calcutta_id = $1::uuid
	AND cer.deleted_at IS NULL
ORDER BY cer.created_at DESC
`

type ListCalcuttaEvaluationRunsByCoreCalcuttaIDRow struct {
	ID                    string
	SimulatedTournamentID string
	CalcuttaSnapshotID    pgtype.UUID
	Purpose               string
	CreatedAt             pgtype.Timestamptz
}

func (q *Queries) ListCalcuttaEvaluationRunsByCoreCalcuttaID(ctx context.Context, dollar_1 string) ([]ListCalcuttaEvaluationRunsByCoreCalcuttaIDRow, error) {
	rows, err := q.db.Query(ctx, listCalcuttaEvaluationRunsByCoreCalcuttaID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCalcuttaEvaluationRunsByCoreCalcuttaIDRow
	for rows.Next() {
		var i ListCalcuttaEvaluationRunsByCoreCalcuttaIDRow
		if err := rows.Scan(
			&i.ID,
			&i.SimulatedTournamentID,
			&i.CalcuttaSnapshotID,
			&i.Purpose,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptimizedEntriesByCoreCalcuttaID = `-- name: ListOptimizedEntriesByCoreCalcuttaID :many
SELECT
	oe.id,
	oe.run_key,
	oe.simulated_tournament_id,
	oe.calcutta_id,
	oe.purpose,
	oe.returns_model_key,
	oe.investment_model_key,
	oe.optimizer_kind,
	oe.optimizer_params_json AS params_json,
	oe.git_sha,
	oe.created_at
FROM derived.optimized_entries oe
WHERE oe.calcutta_id = $1::uuid
	AND oe.deleted_at IS NULL
ORDER BY oe.created_at DESC
`

type ListOptimizedEntriesByCoreCalcuttaIDRow struct {
	ID                    string
	RunKey                *string
	SimulatedTournamentID pgtype.UUID
	CalcuttaID            string
	Purpose               *string
	ReturnsModelKey       *string
	InvestmentModelKey    *string
	OptimizerKind         string
	ParamsJson            []byte
	GitSha                *string
	CreatedAt             pgtype.Timestamptz
}

func (q *Queries) ListOptimizedEntriesByCoreCalcuttaID(ctx context.Context, dollar_1 string) ([]ListOptimizedEntriesByCoreCalcuttaIDRow, error) {
	rows, err := q.db.Query(ctx, listOptimizedEntriesByCoreCalcuttaID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOptimizedEntriesByCoreCalcuttaIDRow
	for rows.Next() {
		var i ListOptimizedEntriesByCoreCalcuttaIDRow
		if err := rows.Scan(
			&i.ID,
			&i.RunKey,
			&i.SimulatedTournamentID,
			&i.CalcuttaID,
			&i.Purpose,
			&i.ReturnsModelKey,
			&i.InvestmentModelKey,
			&i.OptimizerKind,
			&i.ParamsJson,
			&i.GitSha,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
