// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ml_analytics_tournament.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getTournamentSimStatsByCoreTournamentID = `-- name: GetTournamentSimStatsByCoreTournamentID :one
WITH tournament_info AS (
 	SELECT
 		bt.id as tournament_id,
 		bt.season
 	FROM derived.tournaments bt
 	WHERE bt.core_tournament_id = $1::uuid
 	LIMIT 1
 ),
sim_stats AS (
	SELECT
		COUNT(DISTINCT sim_id)::int as total_simulations,
		COUNT(DISTINCT team_id)::int as total_teams
	FROM derived.simulated_teams st
	JOIN tournament_info ti ON st.tournament_id = ti.tournament_id
),
prediction_stats AS (
 	SELECT COUNT(*)::int as total_predictions
 	FROM derived.predicted_game_outcomes pgo
 	JOIN tournament_info ti ON pgo.tournament_id = ti.tournament_id
 ),
win_stats AS (
	SELECT
		AVG(wins)::double precision as mean_wins,
		PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY wins)::double precision as median_wins,
		MAX(wins)::int as max_wins
	FROM derived.simulated_teams st
	JOIN tournament_info ti ON st.tournament_id = ti.tournament_id
)
SELECT
	ti.tournament_id,
	ti.season,
	COALESCE(ss.total_simulations, 0)::int as total_simulations,
	COALESCE(ps.total_predictions, 0)::int as total_predictions,
	COALESCE(ws.mean_wins, 0.0)::double precision as mean_wins,
	COALESCE(ws.median_wins, 0.0)::double precision as median_wins,
	COALESCE(ws.max_wins, 0)::int as max_wins,
	NOW()::timestamptz as last_updated
FROM tournament_info ti
LEFT JOIN sim_stats ss ON true
LEFT JOIN prediction_stats ps ON true
LEFT JOIN win_stats ws ON true
`

type GetTournamentSimStatsByCoreTournamentIDRow struct {
	TournamentID     string
	Season           int32
	TotalSimulations int32
	TotalPredictions int32
	MeanWins         float64
	MedianWins       float64
	MaxWins          int32
	LastUpdated      pgtype.Timestamptz
}

func (q *Queries) GetTournamentSimStatsByCoreTournamentID(ctx context.Context, coreTournamentID string) (GetTournamentSimStatsByCoreTournamentIDRow, error) {
	row := q.db.QueryRow(ctx, getTournamentSimStatsByCoreTournamentID, coreTournamentID)
	var i GetTournamentSimStatsByCoreTournamentIDRow
	err := row.Scan(
		&i.TournamentID,
		&i.Season,
		&i.TotalSimulations,
		&i.TotalPredictions,
		&i.MeanWins,
		&i.MedianWins,
		&i.MaxWins,
		&i.LastUpdated,
	)
	return i, err
}

const getTournamentSimStatsByYear = `-- name: GetTournamentSimStatsByYear :one
SELECT 
    t.id as tournament_id,
    t.season,
    COUNT(DISTINCT st.sim_id)::int as n_sims,
    COUNT(DISTINCT st.team_id)::int as n_teams,
    AVG(st.wins + st.byes)::float as avg_progress,
    MAX(st.wins + st.byes)::int as max_progress
FROM derived.tournaments t
JOIN derived.simulated_teams st ON t.id = st.tournament_id
WHERE t.season = $1::int
GROUP BY t.id, t.season
`

type GetTournamentSimStatsByYearRow struct {
	TournamentID string
	Season       int32
	NSims        int32
	NTeams       int32
	AvgProgress  float64
	MaxProgress  int32
}

func (q *Queries) GetTournamentSimStatsByYear(ctx context.Context, dollar_1 int32) (GetTournamentSimStatsByYearRow, error) {
	row := q.db.QueryRow(ctx, getTournamentSimStatsByYear, dollar_1)
	var i GetTournamentSimStatsByYearRow
	err := row.Scan(
		&i.TournamentID,
		&i.Season,
		&i.NSims,
		&i.NTeams,
		&i.AvgProgress,
		&i.MaxProgress,
	)
	return i, err
}

const listTournamentSimulationBatchesByCoreTournamentID = `-- name: ListTournamentSimulationBatchesByCoreTournamentID :many
SELECT
	b.id,
	b.tournament_id,
	b.simulation_state_id,
	b.n_sims,
	b.seed,
	b.probability_source_key,
	b.created_at
FROM derived.simulated_tournaments b
WHERE b.tournament_id = $1::uuid
	AND b.deleted_at IS NULL
ORDER BY b.created_at DESC
`

type ListTournamentSimulationBatchesByCoreTournamentIDRow struct {
	ID                   string
	TournamentID         string
	SimulationStateID    string
	NSims                int32
	Seed                 int32
	ProbabilitySourceKey string
	CreatedAt            pgtype.Timestamptz
}

func (q *Queries) ListTournamentSimulationBatchesByCoreTournamentID(ctx context.Context, dollar_1 string) ([]ListTournamentSimulationBatchesByCoreTournamentIDRow, error) {
	rows, err := q.db.Query(ctx, listTournamentSimulationBatchesByCoreTournamentID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTournamentSimulationBatchesByCoreTournamentIDRow
	for rows.Next() {
		var i ListTournamentSimulationBatchesByCoreTournamentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.TournamentID,
			&i.SimulationStateID,
			&i.NSims,
			&i.Seed,
			&i.ProbabilitySourceKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
