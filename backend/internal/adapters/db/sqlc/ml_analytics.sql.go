// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ml_analytics.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActualEntryPortfolio = `-- name: GetActualEntryPortfolio :many
SELECT 
    t.team_key,
    t.school_name,
    t.seed,
    t.region,
    eb.bid_amount
FROM bronze_entry_bids eb
JOIN bronze_teams t ON eb.team_key = t.team_key
JOIN gold_optimization_runs r ON eb.calcutta_key = r.calcutta_key
WHERE r.run_id = $1 AND eb.entry_key = $2
ORDER BY eb.bid_amount DESC
`

type GetActualEntryPortfolioParams struct {
	RunID    string
	EntryKey string
}

type GetActualEntryPortfolioRow struct {
	TeamKey    string
	SchoolName string
	Seed       int32
	Region     string
	BidAmount  int32
}

// For actual entries from the auction
func (q *Queries) GetActualEntryPortfolio(ctx context.Context, arg GetActualEntryPortfolioParams) ([]GetActualEntryPortfolioRow, error) {
	rows, err := q.db.Query(ctx, getActualEntryPortfolio, arg.RunID, arg.EntryKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActualEntryPortfolioRow
	for rows.Next() {
		var i GetActualEntryPortfolioRow
		if err := rows.Scan(
			&i.TeamKey,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryPerformanceByRunID = `-- name: GetEntryPerformanceByRunID :one
SELECT 
    ep.n_teams,
    ep.total_bid_points,
    ep.mean_normalized_payout,
    ep.p_top1,
    ep.p_in_money,
    ep.percentile_rank
FROM gold_entry_performance ep
WHERE ep.run_id = $1::text AND ep.is_our_strategy = true
`

type GetEntryPerformanceByRunIDRow struct {
	NTeams               int32
	TotalBidPoints       int32
	MeanNormalizedPayout pgtype.Numeric
	PTop1                pgtype.Numeric
	PInMoney             pgtype.Numeric
	PercentileRank       pgtype.Numeric
}

func (q *Queries) GetEntryPerformanceByRunID(ctx context.Context, dollar_1 string) (GetEntryPerformanceByRunIDRow, error) {
	row := q.db.QueryRow(ctx, getEntryPerformanceByRunID, dollar_1)
	var i GetEntryPerformanceByRunIDRow
	err := row.Scan(
		&i.NTeams,
		&i.TotalBidPoints,
		&i.MeanNormalizedPayout,
		&i.PTop1,
		&i.PInMoney,
		&i.PercentileRank,
	)
	return i, err
}

const getEntryPortfolio = `-- name: GetEntryPortfolio :many
SELECT 
    t.team_key,
    t.school_name,
    t.seed,
    t.region,
    reb.bid_amount_points as bid_amount
FROM gold_recommended_entry_bids reb
JOIN bronze_teams t ON reb.team_key = t.team_key
WHERE reb.run_id = $1
ORDER BY reb.bid_amount_points DESC
`

type GetEntryPortfolioRow struct {
	TeamKey    string
	SchoolName string
	Seed       int32
	Region     string
	BidAmount  int32
}

// For our strategy entry
func (q *Queries) GetEntryPortfolio(ctx context.Context, runID string) ([]GetEntryPortfolioRow, error) {
	rows, err := q.db.Query(ctx, getEntryPortfolio, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryPortfolioRow
	for rows.Next() {
		var i GetEntryPortfolioRow
		if err := rows.Scan(
			&i.TeamKey,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryRankingsByRunID = `-- name: GetEntryRankingsByRunID :many
SELECT 
    er.rank,
    er.entry_key,
    er.is_our_strategy,
    ep.n_teams,
    ep.total_bid_points,
    ep.mean_normalized_payout,
    ep.percentile_rank,
    ep.p_top1,
    ep.p_in_money,
    er.total_entries
FROM view_entry_rankings er
JOIN gold_entry_performance ep ON ep.run_id = er.run_id AND ep.entry_key = er.entry_key
WHERE er.run_id = $1::text
ORDER BY er.rank
LIMIT $2::int OFFSET $3::int
`

type GetEntryRankingsByRunIDParams struct {
	Column1 string
	Column2 int32
	Column3 int32
}

type GetEntryRankingsByRunIDRow struct {
	Rank                 int64
	EntryKey             string
	IsOurStrategy        bool
	NTeams               int32
	TotalBidPoints       int32
	MeanNormalizedPayout pgtype.Numeric
	PercentileRank       pgtype.Numeric
	PTop1                pgtype.Numeric
	PInMoney             pgtype.Numeric
	TotalEntries         int64
}

func (q *Queries) GetEntryRankingsByRunID(ctx context.Context, arg GetEntryRankingsByRunIDParams) ([]GetEntryRankingsByRunIDRow, error) {
	rows, err := q.db.Query(ctx, getEntryRankingsByRunID, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryRankingsByRunIDRow
	for rows.Next() {
		var i GetEntryRankingsByRunIDRow
		if err := rows.Scan(
			&i.Rank,
			&i.EntryKey,
			&i.IsOurStrategy,
			&i.NTeams,
			&i.TotalBidPoints,
			&i.MeanNormalizedPayout,
			&i.PercentileRank,
			&i.PTop1,
			&i.PInMoney,
			&i.TotalEntries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntrySimulationSummary = `-- name: GetEntrySimulationSummary :one
SELECT 
    COUNT(*)::int as total_simulations,
    AVG(payout_cents)::float as mean_payout_cents,
    AVG(total_points)::float as mean_points,
    AVG(normalized_payout)::float as mean_normalized_payout,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY payout_cents)::int as p50_payout_cents,
    PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY payout_cents)::int as p90_payout_cents
FROM gold_entry_simulation_outcomes
WHERE run_id = $1::text AND entry_key = $2::text
`

type GetEntrySimulationSummaryParams struct {
	Column1 string
	Column2 string
}

type GetEntrySimulationSummaryRow struct {
	TotalSimulations     int32
	MeanPayoutCents      float64
	MeanPoints           float64
	MeanNormalizedPayout float64
	P50PayoutCents       int32
	P90PayoutCents       int32
}

func (q *Queries) GetEntrySimulationSummary(ctx context.Context, arg GetEntrySimulationSummaryParams) (GetEntrySimulationSummaryRow, error) {
	row := q.db.QueryRow(ctx, getEntrySimulationSummary, arg.Column1, arg.Column2)
	var i GetEntrySimulationSummaryRow
	err := row.Scan(
		&i.TotalSimulations,
		&i.MeanPayoutCents,
		&i.MeanPoints,
		&i.MeanNormalizedPayout,
		&i.P50PayoutCents,
		&i.P90PayoutCents,
	)
	return i, err
}

const getEntrySimulationsByKey = `-- name: GetEntrySimulationsByKey :many
SELECT 
    sim_id,
    payout_cents,
    total_points,
    finish_position,
    is_tied,
    normalized_payout,
    n_entries
FROM gold_entry_simulation_outcomes
WHERE run_id = $1::text AND entry_key = $2::text
ORDER BY payout_cents DESC, total_points DESC
LIMIT $3::int OFFSET $4::int
`

type GetEntrySimulationsByKeyParams struct {
	Column1 string
	Column2 string
	Column3 int32
	Column4 int32
}

type GetEntrySimulationsByKeyRow struct {
	SimID            int32
	PayoutCents      int32
	TotalPoints      pgtype.Numeric
	FinishPosition   int32
	IsTied           bool
	NormalizedPayout pgtype.Numeric
	NEntries         int32
}

func (q *Queries) GetEntrySimulationsByKey(ctx context.Context, arg GetEntrySimulationsByKeyParams) ([]GetEntrySimulationsByKeyRow, error) {
	rows, err := q.db.Query(ctx, getEntrySimulationsByKey,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntrySimulationsByKeyRow
	for rows.Next() {
		var i GetEntrySimulationsByKeyRow
		if err := rows.Scan(
			&i.SimID,
			&i.PayoutCents,
			&i.TotalPoints,
			&i.FinishPosition,
			&i.IsTied,
			&i.NormalizedPayout,
			&i.NEntries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptimizationRunByID = `-- name: GetOptimizationRunByID :one
SELECT 
    run_id,
    calcutta_key,
    strategy,
    n_sims,
    seed,
    budget_points,
    run_timestamp
FROM gold_optimization_runs
WHERE run_id = $1::text
`

type GetOptimizationRunByIDRow struct {
	RunID        string
	CalcuttaKey  string
	Strategy     string
	NSims        int32
	Seed         int32
	BudgetPoints int32
	RunTimestamp pgtype.Timestamp
}

func (q *Queries) GetOptimizationRunByID(ctx context.Context, dollar_1 string) (GetOptimizationRunByIDRow, error) {
	row := q.db.QueryRow(ctx, getOptimizationRunByID, dollar_1)
	var i GetOptimizationRunByIDRow
	err := row.Scan(
		&i.RunID,
		&i.CalcuttaKey,
		&i.Strategy,
		&i.NSims,
		&i.Seed,
		&i.BudgetPoints,
		&i.RunTimestamp,
	)
	return i, err
}

const getOptimizationRunsByYear = `-- name: GetOptimizationRunsByYear :many
SELECT 
    r.run_id,
    r.calcutta_key,
    r.strategy,
    r.n_sims,
    r.seed,
    r.budget_points,
    r.run_timestamp
FROM gold_optimization_runs r
JOIN bronze_calcuttas bc ON bc.calcutta_key = r.calcutta_key
JOIN bronze_tournaments bt ON bt.tournament_key = bc.tournament_key
WHERE bt.season = $1::int
ORDER BY r.run_timestamp DESC
`

type GetOptimizationRunsByYearRow struct {
	RunID        string
	CalcuttaKey  string
	Strategy     string
	NSims        int32
	Seed         int32
	BudgetPoints int32
	RunTimestamp pgtype.Timestamp
}

func (q *Queries) GetOptimizationRunsByYear(ctx context.Context, dollar_1 int32) ([]GetOptimizationRunsByYearRow, error) {
	rows, err := q.db.Query(ctx, getOptimizationRunsByYear, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOptimizationRunsByYearRow
	for rows.Next() {
		var i GetOptimizationRunsByYearRow
		if err := rows.Scan(
			&i.RunID,
			&i.CalcuttaKey,
			&i.Strategy,
			&i.NSims,
			&i.Seed,
			&i.BudgetPoints,
			&i.RunTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOurEntryBidsByRunID = `-- name: GetOurEntryBidsByRunID :many
SELECT 
    t.team_key,
    t.school_name,
    t.seed,
    t.region,
    reb.bid_amount_points,
    dir.expected_points,
    dir.predicted_market_points,
    dir.actual_market_points,
    dir.our_ownership,
    dir.expected_roi,
    dir.our_roi,
    dir.roi_degradation
FROM gold_recommended_entry_bids reb
JOIN bronze_teams t ON t.team_key = reb.team_key
LEFT JOIN gold_detailed_investment_report dir ON dir.run_id = reb.run_id AND dir.team_key = reb.team_key
WHERE reb.run_id = $1::text
ORDER BY reb.bid_amount_points DESC
`

type GetOurEntryBidsByRunIDRow struct {
	TeamKey               string
	SchoolName            string
	Seed                  int32
	Region                string
	BidAmountPoints       int32
	ExpectedPoints        pgtype.Numeric
	PredictedMarketPoints pgtype.Numeric
	ActualMarketPoints    pgtype.Numeric
	OurOwnership          pgtype.Numeric
	ExpectedRoi           pgtype.Numeric
	OurRoi                pgtype.Numeric
	RoiDegradation        pgtype.Numeric
}

func (q *Queries) GetOurEntryBidsByRunID(ctx context.Context, dollar_1 string) ([]GetOurEntryBidsByRunIDRow, error) {
	rows, err := q.db.Query(ctx, getOurEntryBidsByRunID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOurEntryBidsByRunIDRow
	for rows.Next() {
		var i GetOurEntryBidsByRunIDRow
		if err := rows.Scan(
			&i.TeamKey,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidAmountPoints,
			&i.ExpectedPoints,
			&i.PredictedMarketPoints,
			&i.ActualMarketPoints,
			&i.OurOwnership,
			&i.ExpectedRoi,
			&i.OurRoi,
			&i.RoiDegradation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamPerformanceByKey = `-- name: GetTeamPerformanceByKey :one
WITH round_distribution AS (
    SELECT 
        st.team_key,
        CASE (st.wins + st.byes)
            WHEN 0 THEN 'R64'
            WHEN 1 THEN 'R64'
            WHEN 2 THEN 'R32'
            WHEN 3 THEN 'S16'
            WHEN 4 THEN 'E8'
            WHEN 5 THEN 'F4'
            WHEN 6 THEN 'Finals'
            WHEN 7 THEN 'Champion'
            ELSE 'Unknown'
        END as round_name,
        COUNT(*)::int as count
    FROM bronze_simulated_tournaments st
    JOIN bronze_teams t ON t.team_key = st.team_key
    WHERE st.team_key = $1::text
    GROUP BY st.team_key, round_name
)
SELECT 
    t.team_key,
    t.school_name,
    t.seed,
    t.region,
    t.kenpom_net,
    COUNT(DISTINCT st.sim_id)::int as total_sims,
    AVG(st.wins)::float as avg_wins,
    AVG(CASE (st.wins + st.byes)
        WHEN 0 THEN 0
        WHEN 1 THEN 0
        WHEN 2 THEN 50
        WHEN 3 THEN 150
        WHEN 4 THEN 300
        WHEN 5 THEN 500
        WHEN 6 THEN 750
        WHEN 7 THEN 1050
        ELSE 0
    END)::float as avg_points,
    tv.p_champion,
    tv.p_finals,
    tv.p_final_four,
    tv.p_elite_eight,
    tv.p_sweet_sixteen,
    tv.p_round_32,
    jsonb_object_agg(rd.round_name, rd.count) as round_distribution
FROM bronze_teams t
JOIN bronze_simulated_tournaments st ON st.team_key = t.team_key
LEFT JOIN silver_team_tournament_value tv ON tv.team_key = t.team_key
LEFT JOIN round_distribution rd ON rd.team_key = t.team_key
WHERE t.team_key = $1::text
GROUP BY t.team_key, t.school_name, t.seed, t.region, t.kenpom_net,
         tv.p_champion, tv.p_finals, tv.p_final_four, tv.p_elite_eight,
         tv.p_sweet_sixteen, tv.p_round_32
`

type GetTeamPerformanceByKeyRow struct {
	TeamKey           string
	SchoolName        string
	Seed              int32
	Region            string
	KenpomNet         pgtype.Numeric
	TotalSims         int32
	AvgWins           float64
	AvgPoints         float64
	PChampion         pgtype.Numeric
	PFinals           pgtype.Numeric
	PFinalFour        pgtype.Numeric
	PEliteEight       pgtype.Numeric
	PSweetSixteen     pgtype.Numeric
	PRound32          pgtype.Numeric
	RoundDistribution []byte
}

func (q *Queries) GetTeamPerformanceByKey(ctx context.Context, dollar_1 string) (GetTeamPerformanceByKeyRow, error) {
	row := q.db.QueryRow(ctx, getTeamPerformanceByKey, dollar_1)
	var i GetTeamPerformanceByKeyRow
	err := row.Scan(
		&i.TeamKey,
		&i.SchoolName,
		&i.Seed,
		&i.Region,
		&i.KenpomNet,
		&i.TotalSims,
		&i.AvgWins,
		&i.AvgPoints,
		&i.PChampion,
		&i.PFinals,
		&i.PFinalFour,
		&i.PEliteEight,
		&i.PSweetSixteen,
		&i.PRound32,
		&i.RoundDistribution,
	)
	return i, err
}

const getTeamPredictionsByYear = `-- name: GetTeamPredictionsByYear :many
SELECT 
    t.team_key,
    t.school_name,
    t.seed,
    t.region,
    tv.expected_points,
    pms.predicted_share_of_pool as predicted_market_share,
    (pms.predicted_share_of_pool * bc.budget_points)::float as predicted_market_points,
    tv.p_champion,
    t.kenpom_net
FROM bronze_teams t
JOIN bronze_tournaments bt ON bt.tournament_key = t.tournament_key
JOIN bronze_calcuttas bc ON bc.tournament_key = bt.tournament_key
LEFT JOIN silver_team_tournament_value tv ON tv.team_key = t.team_key
LEFT JOIN silver_predicted_market_share pms ON pms.team_key = t.team_key AND pms.calcutta_key = bc.calcutta_key
WHERE bt.season = $1::int
ORDER BY tv.expected_points DESC NULLS LAST
`

type GetTeamPredictionsByYearRow struct {
	TeamKey               string
	SchoolName            string
	Seed                  int32
	Region                string
	ExpectedPoints        pgtype.Numeric
	PredictedMarketShare  pgtype.Numeric
	PredictedMarketPoints float64
	PChampion             pgtype.Numeric
	KenpomNet             pgtype.Numeric
}

func (q *Queries) GetTeamPredictionsByYear(ctx context.Context, dollar_1 int32) ([]GetTeamPredictionsByYearRow, error) {
	rows, err := q.db.Query(ctx, getTeamPredictionsByYear, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamPredictionsByYearRow
	for rows.Next() {
		var i GetTeamPredictionsByYearRow
		if err := rows.Scan(
			&i.TeamKey,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.ExpectedPoints,
			&i.PredictedMarketShare,
			&i.PredictedMarketPoints,
			&i.PChampion,
			&i.KenpomNet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentSimStatsByYear = `-- name: GetTournamentSimStatsByYear :one

SELECT 
    t.tournament_key,
    t.season,
    COUNT(DISTINCT st.sim_id)::int as n_sims,
    COUNT(DISTINCT st.team_key)::int as n_teams,
    AVG(st.wins + st.byes)::float as avg_progress,
    MAX(st.wins + st.byes)::int as max_progress
FROM bronze_tournaments t
JOIN bronze_simulated_tournaments st ON t.tournament_key = st.tournament_key
WHERE t.season = $1::int
GROUP BY t.tournament_key, t.season
`

type GetTournamentSimStatsByYearRow struct {
	TournamentKey string
	Season        int32
	NSims         int32
	NTeams        int32
	AvgProgress   float64
	MaxProgress   int32
}

// ML Analytics Queries
// For tournament simulation and entry evaluation data
func (q *Queries) GetTournamentSimStatsByYear(ctx context.Context, dollar_1 int32) (GetTournamentSimStatsByYearRow, error) {
	row := q.db.QueryRow(ctx, getTournamentSimStatsByYear, dollar_1)
	var i GetTournamentSimStatsByYearRow
	err := row.Scan(
		&i.TournamentKey,
		&i.Season,
		&i.NSims,
		&i.NTeams,
		&i.AvgProgress,
		&i.MaxProgress,
	)
	return i, err
}
