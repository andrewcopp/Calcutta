// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ml_analytics.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActualEntryPortfolio = `-- name: GetActualEntryPortfolio :many
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    eb.bid_amount_points
FROM lab_bronze.entry_bids eb
JOIN lab_bronze.teams t ON eb.team_id = t.id
JOIN lab_bronze.calcuttas bc ON bc.id = eb.calcutta_id
JOIN lab_gold.strategy_generation_runs sgr
	ON sgr.calcutta_id = bc.core_calcutta_id
	AND sgr.run_key = $1
	AND sgr.deleted_at IS NULL
WHERE eb.entry_name = $2
ORDER BY eb.bid_amount_points DESC
`

type GetActualEntryPortfolioParams struct {
	RunID     *string
	EntryName string
}

type GetActualEntryPortfolioRow struct {
	TeamID          string
	SchoolName      string
	Seed            *int32
	Region          *string
	BidAmountPoints int32
}

// For actual entries from the auction
func (q *Queries) GetActualEntryPortfolio(ctx context.Context, arg GetActualEntryPortfolioParams) ([]GetActualEntryPortfolioRow, error) {
	rows, err := q.db.Query(ctx, getActualEntryPortfolio, arg.RunID, arg.EntryName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActualEntryPortfolioRow
	for rows.Next() {
		var i GetActualEntryPortfolioRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidAmountPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryPerformanceByCalcuttaEvaluationRunID = `-- name: GetEntryPerformanceByCalcuttaEvaluationRunID :many
SELECT
	ROW_NUMBER() OVER (ORDER BY gep.mean_normalized_payout DESC)::int as rank,
	gep.entry_name,
	COALESCE(gep.mean_normalized_payout, 0.0)::double precision as mean_normalized_payout,
	COALESCE(gep.median_normalized_payout, 0.0)::double precision as median_normalized_payout,
	COALESCE(gep.p_top1, 0.0)::double precision as p_top1,
	COALESCE(gep.p_in_money, 0.0)::double precision as p_in_money,
	COALESCE((
		SELECT st.n_sims::int
		FROM derived.calcutta_evaluation_runs cer
		JOIN derived.simulated_tournaments st
			ON st.id = cer.simulated_tournament_id
			AND st.deleted_at IS NULL
		WHERE cer.id = $1::uuid
			AND cer.deleted_at IS NULL
		LIMIT 1
	), 0)::int as total_simulations
FROM derived.entry_performance gep
WHERE gep.calcutta_evaluation_run_id = $1::uuid
	AND gep.deleted_at IS NULL
ORDER BY gep.mean_normalized_payout DESC
`

type GetEntryPerformanceByCalcuttaEvaluationRunIDRow struct {
	Rank                   int32
	EntryName              string
	MeanNormalizedPayout   float64
	MedianNormalizedPayout float64
	PTop1                  float64
	PInMoney               float64
	TotalSimulations       int32
}

func (q *Queries) GetEntryPerformanceByCalcuttaEvaluationRunID(ctx context.Context, dollar_1 string) ([]GetEntryPerformanceByCalcuttaEvaluationRunIDRow, error) {
	rows, err := q.db.Query(ctx, getEntryPerformanceByCalcuttaEvaluationRunID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryPerformanceByCalcuttaEvaluationRunIDRow
	for rows.Next() {
		var i GetEntryPerformanceByCalcuttaEvaluationRunIDRow
		if err := rows.Scan(
			&i.Rank,
			&i.EntryName,
			&i.MeanNormalizedPayout,
			&i.MedianNormalizedPayout,
			&i.PTop1,
			&i.PInMoney,
			&i.TotalSimulations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryPerformanceByRunID = `-- name: GetEntryPerformanceByRunID :many
SELECT
    ROW_NUMBER() OVER (ORDER BY gep.mean_normalized_payout DESC)::int as rank,
    gep.entry_name,
    COALESCE(gep.mean_normalized_payout, 0.0)::double precision as mean_normalized_payout,
    COALESCE(gep.median_normalized_payout, 0.0)::double precision as median_normalized_payout,
    COALESCE(gep.p_top1, 0.0)::double precision as p_top1,
    COALESCE(gep.p_in_money, 0.0)::double precision as p_in_money,
    COALESCE((
		SELECT st.n_sims::int
		FROM derived.calcutta_evaluation_runs cer
		JOIN derived.simulated_tournaments st
			ON st.id = cer.simulated_tournament_id
			AND st.deleted_at IS NULL
		WHERE cer.id = gep.calcutta_evaluation_run_id
			AND cer.deleted_at IS NULL
		LIMIT 1
	), 0)::int as total_simulations
FROM derived.entry_performance gep
WHERE gep.run_id = $1::text
ORDER BY gep.mean_normalized_payout DESC
`

type GetEntryPerformanceByRunIDRow struct {
	Rank                   int32
	EntryName              string
	MeanNormalizedPayout   float64
	MedianNormalizedPayout float64
	PTop1                  float64
	PInMoney               float64
	TotalSimulations       int32
}

func (q *Queries) GetEntryPerformanceByRunID(ctx context.Context, dollar_1 string) ([]GetEntryPerformanceByRunIDRow, error) {
	rows, err := q.db.Query(ctx, getEntryPerformanceByRunID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryPerformanceByRunIDRow
	for rows.Next() {
		var i GetEntryPerformanceByRunIDRow
		if err := rows.Scan(
			&i.Rank,
			&i.EntryName,
			&i.MeanNormalizedPayout,
			&i.MedianNormalizedPayout,
			&i.PTop1,
			&i.PInMoney,
			&i.TotalSimulations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryPortfolio = `-- name: GetEntryPortfolio :many




SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    reb.recommended_bid_points as bid_amount
FROM lab_gold.recommended_entry_bids reb
JOIN lab_bronze.teams t ON reb.team_id = t.id
WHERE reb.run_id = $1
ORDER BY reb.recommended_bid_points DESC
`

type GetEntryPortfolioRow struct {
	TeamID     string
	SchoolName string
	Seed       *int32
	Region     *string
	BidAmount  int32
}

// Removed - table doesn't exist in new schema
// Removed - view doesn't exist in new schema
// Removed - table schema changed
// Removed - table schema changed
// For our strategy entry
func (q *Queries) GetEntryPortfolio(ctx context.Context, runID string) ([]GetEntryPortfolioRow, error) {
	rows, err := q.db.Query(ctx, getEntryPortfolio, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryPortfolioRow
	for rows.Next() {
		var i GetEntryPortfolioRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryPortfolioByStrategyGenerationRunID = `-- name: GetEntryPortfolioByStrategyGenerationRunID :many
SELECT
	t.id as team_id,
	t.school_name,
	t.seed,
	t.region,
	reb.recommended_bid_points as bid_amount
FROM lab_gold.recommended_entry_bids reb
JOIN lab_bronze.teams t ON reb.team_id = t.id
WHERE reb.strategy_generation_run_id = $1::uuid
ORDER BY reb.recommended_bid_points DESC
`

type GetEntryPortfolioByStrategyGenerationRunIDRow struct {
	TeamID     string
	SchoolName string
	Seed       *int32
	Region     *string
	BidAmount  int32
}

// For our strategy entry (lineage-native)
func (q *Queries) GetEntryPortfolioByStrategyGenerationRunID(ctx context.Context, strategyGenerationRunID string) ([]GetEntryPortfolioByStrategyGenerationRunIDRow, error) {
	rows, err := q.db.Query(ctx, getEntryPortfolioByStrategyGenerationRunID, strategyGenerationRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryPortfolioByStrategyGenerationRunIDRow
	for rows.Next() {
		var i GetEntryPortfolioByStrategyGenerationRunIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryRankingsByRunKey = `-- name: GetEntryRankingsByRunKey :many
WITH strategy_run AS (
	SELECT
		sgr.id AS strategy_generation_run_id,
		sgr.calcutta_id AS core_calcutta_id
	FROM lab_gold.strategy_generation_runs sgr
	WHERE sgr.run_key = $3::text
		AND sgr.deleted_at IS NULL
	LIMIT 1
),
lab_calcutta AS (
	SELECT bc.id AS lab_calcutta_id
	FROM lab_bronze.calcuttas bc
	JOIN strategy_run sr ON sr.core_calcutta_id = bc.core_calcutta_id
	LIMIT 1
),
base AS (
	SELECT
		gep.entry_name,
		COALESCE(gep.mean_normalized_payout, 0.0)::double precision AS mean_normalized_payout,
		COALESCE(gep.p_top1, 0.0)::double precision AS p_top1,
		COALESCE(gep.p_in_money, 0.0)::double precision AS p_in_money
	FROM derived.entry_performance gep
	WHERE gep.run_id = $3::text
		AND gep.deleted_at IS NULL
),
with_totals AS (
	SELECT
		ROW_NUMBER() OVER (ORDER BY b.mean_normalized_payout DESC)::int AS rank,
		b.entry_name,
		(b.entry_name IN ('Our Strategy', 'our_strategy', 'Out Strategy'))::boolean AS is_our_strategy,
		b.mean_normalized_payout,
		b.p_top1,
		b.p_in_money,
		COUNT(*) OVER ()::int AS total_entries
	FROM base b
),
with_percentile AS (
	SELECT
		wt.rank, wt.entry_name, wt.is_our_strategy, wt.mean_normalized_payout, wt.p_top1, wt.p_in_money, wt.total_entries,
		CASE
			WHEN wt.total_entries > 1 THEN (wt.total_entries - wt.rank)::double precision / (wt.total_entries - 1)::double precision
			ELSE 1.0::double precision
		END AS percentile_rank
	FROM with_totals wt
),
with_bids AS (
	SELECT
		wp.rank,
		wp.entry_name,
		wp.is_our_strategy,
		CASE
			WHEN wp.is_our_strategy THEN COALESCE(os.n_teams, 0)
			ELSE COALESCE(ab.n_teams, 0)
		END::int AS n_teams,
		CASE
			WHEN wp.is_our_strategy THEN COALESCE(os.total_bid_points, 0)
			ELSE COALESCE(ab.total_bid_points, 0)
		END::int AS total_bid_points,
		wp.mean_normalized_payout,
		wp.percentile_rank,
		wp.p_top1,
		wp.p_in_money,
		wp.total_entries
	FROM with_percentile wp
	LEFT JOIN (
		SELECT
			COUNT(*)::int AS n_teams,
			COALESCE(SUM(recommended_bid_points), 0)::int AS total_bid_points
		FROM lab_gold.recommended_entry_bids reb
		JOIN strategy_run sr ON sr.strategy_generation_run_id = reb.strategy_generation_run_id
		WHERE reb.deleted_at IS NULL
	) os ON wp.is_our_strategy
	LEFT JOIN (
		SELECT
			eb.entry_name,
			COUNT(*)::int AS n_teams,
			COALESCE(SUM(eb.bid_amount_points), 0)::int AS total_bid_points
		FROM lab_bronze.entry_bids eb
		JOIN lab_calcutta lc ON lc.lab_calcutta_id = eb.calcutta_id
		WHERE eb.deleted_at IS NULL
		GROUP BY eb.entry_name
	) ab ON (NOT wp.is_our_strategy AND ab.entry_name = wp.entry_name)
)
SELECT
	rank,
	entry_name AS entry_key,
	is_our_strategy,
	n_teams,
	total_bid_points,
	mean_normalized_payout,
	percentile_rank,
	p_top1,
	p_in_money,
	total_entries
FROM with_bids
ORDER BY rank ASC
LIMIT $2::int
OFFSET $1::int
`

type GetEntryRankingsByRunKeyParams struct {
	PageOffset int32
	PageLimit  int32
	RunID      string
}

type GetEntryRankingsByRunKeyRow struct {
	Rank                 int32
	EntryKey             string
	IsOurStrategy        bool
	NTeams               int32
	TotalBidPoints       int32
	MeanNormalizedPayout float64
	PercentileRank       float64
	PTop1                float64
	PInMoney             float64
	TotalEntries         int32
}

func (q *Queries) GetEntryRankingsByRunKey(ctx context.Context, arg GetEntryRankingsByRunKeyParams) ([]GetEntryRankingsByRunKeyRow, error) {
	rows, err := q.db.Query(ctx, getEntryRankingsByRunKey, arg.PageOffset, arg.PageLimit, arg.RunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryRankingsByRunKeyRow
	for rows.Next() {
		var i GetEntryRankingsByRunKeyRow
		if err := rows.Scan(
			&i.Rank,
			&i.EntryKey,
			&i.IsOurStrategy,
			&i.NTeams,
			&i.TotalBidPoints,
			&i.MeanNormalizedPayout,
			&i.PercentileRank,
			&i.PTop1,
			&i.PInMoney,
			&i.TotalEntries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntrySimulationSummaryByRunKeyAndEntryName = `-- name: GetEntrySimulationSummaryByRunKeyAndEntryName :one
WITH per_sim AS (
	SELECT
		sim_id,
		MAX(payout_cents)::double precision AS max_payout_cents,
		COUNT(*)::int AS n_entries
	FROM derived.entry_simulation_outcomes
	WHERE run_id = $1::text
		AND deleted_at IS NULL
	GROUP BY sim_id
),
entry_sims AS (
	SELECT
		eso.sim_id,
		eso.payout_cents::double precision AS payout_cents,
		eso.points_scored::double precision AS points_scored,
		CASE
			WHEN ps.max_payout_cents > 0 THEN (eso.payout_cents::double precision / ps.max_payout_cents)
			ELSE 0.0::double precision
		END AS normalized_payout
	FROM derived.entry_simulation_outcomes eso
	JOIN per_sim ps ON ps.sim_id = eso.sim_id
	WHERE eso.run_id = $1::text
		AND eso.entry_name = $2::text
		AND eso.deleted_at IS NULL
)
SELECT
	COUNT(*)::int AS total_simulations,
	COALESCE(AVG(payout_cents), 0.0)::double precision AS mean_payout_cents,
	COALESCE(AVG(points_scored), 0.0)::double precision AS mean_points,
	COALESCE(AVG(normalized_payout), 0.0)::double precision AS mean_normalized_payout,
	COALESCE(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY payout_cents), 0.0)::double precision AS p50_payout_cents,
	COALESCE(PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY payout_cents), 0.0)::double precision AS p90_payout_cents
FROM entry_sims
`

type GetEntrySimulationSummaryByRunKeyAndEntryNameParams struct {
	RunID     string
	EntryName string
}

type GetEntrySimulationSummaryByRunKeyAndEntryNameRow struct {
	TotalSimulations     int32
	MeanPayoutCents      float64
	MeanPoints           float64
	MeanNormalizedPayout float64
	P50PayoutCents       float64
	P90PayoutCents       float64
}

func (q *Queries) GetEntrySimulationSummaryByRunKeyAndEntryName(ctx context.Context, arg GetEntrySimulationSummaryByRunKeyAndEntryNameParams) (GetEntrySimulationSummaryByRunKeyAndEntryNameRow, error) {
	row := q.db.QueryRow(ctx, getEntrySimulationSummaryByRunKeyAndEntryName, arg.RunID, arg.EntryName)
	var i GetEntrySimulationSummaryByRunKeyAndEntryNameRow
	err := row.Scan(
		&i.TotalSimulations,
		&i.MeanPayoutCents,
		&i.MeanPoints,
		&i.MeanNormalizedPayout,
		&i.P50PayoutCents,
		&i.P90PayoutCents,
	)
	return i, err
}

const getEntrySimulationsByRunKeyAndEntryName = `-- name: GetEntrySimulationsByRunKeyAndEntryName :many
SELECT
	eso.sim_id,
	eso.payout_cents,
	eso.points_scored,
	eso.rank,
	(
		SELECT COUNT(*)::int
		FROM derived.entry_simulation_outcomes eso_all
		WHERE eso_all.run_id = $1::text
			AND eso_all.sim_id = eso.sim_id
			AND eso_all.deleted_at IS NULL
	) AS n_entries,
	(
		SELECT MAX(eso_all.payout_cents)::int
		FROM derived.entry_simulation_outcomes eso_all
		WHERE eso_all.run_id = $1::text
			AND eso_all.sim_id = eso.sim_id
			AND eso_all.deleted_at IS NULL
	) AS max_payout_cents,
	CASE
		WHEN (
			SELECT MAX(eso_all.payout_cents)
			FROM derived.entry_simulation_outcomes eso_all
			WHERE eso_all.run_id = $1::text
				AND eso_all.sim_id = eso.sim_id
				AND eso_all.deleted_at IS NULL
		) > 0 THEN (eso.payout_cents::double precision / (
			SELECT MAX(eso_all.payout_cents)::double precision
			FROM derived.entry_simulation_outcomes eso_all
			WHERE eso_all.run_id = $1::text
				AND eso_all.sim_id = eso.sim_id
				AND eso_all.deleted_at IS NULL
		))
		ELSE 0.0::double precision
	END AS normalized_payout,
	(
		SELECT (COUNT(*) > 1)
		FROM derived.entry_simulation_outcomes eso_tie
		WHERE eso_tie.run_id = $1::text
			AND eso_tie.sim_id = eso.sim_id
			AND eso_tie.rank = eso.rank
			AND eso_tie.deleted_at IS NULL
	) AS is_tied
FROM derived.entry_simulation_outcomes eso
WHERE eso.run_id = $1::text
	AND eso.entry_name = $2::text
	AND eso.deleted_at IS NULL
ORDER BY eso.sim_id ASC
LIMIT $4::int
OFFSET $3::int
`

type GetEntrySimulationsByRunKeyAndEntryNameParams struct {
	RunID      string
	EntryName  string
	PageOffset int32
	PageLimit  int32
}

type GetEntrySimulationsByRunKeyAndEntryNameRow struct {
	SimID            int32
	PayoutCents      int32
	PointsScored     float64
	Rank             int32
	NEntries         int32
	MaxPayoutCents   int32
	NormalizedPayout float64
	IsTied           bool
}

func (q *Queries) GetEntrySimulationsByRunKeyAndEntryName(ctx context.Context, arg GetEntrySimulationsByRunKeyAndEntryNameParams) ([]GetEntrySimulationsByRunKeyAndEntryNameRow, error) {
	rows, err := q.db.Query(ctx, getEntrySimulationsByRunKeyAndEntryName,
		arg.RunID,
		arg.EntryName,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntrySimulationsByRunKeyAndEntryNameRow
	for rows.Next() {
		var i GetEntrySimulationsByRunKeyAndEntryNameRow
		if err := rows.Scan(
			&i.SimID,
			&i.PayoutCents,
			&i.PointsScored,
			&i.Rank,
			&i.NEntries,
			&i.MaxPayoutCents,
			&i.NormalizedPayout,
			&i.IsTied,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestCalcuttaEvaluationRunIDByCoreCalcuttaID = `-- name: GetLatestCalcuttaEvaluationRunIDByCoreCalcuttaID :one
SELECT
	cer.id
FROM derived.calcutta_evaluation_runs cer
JOIN core.calcutta_snapshots cs
	ON cs.id = cer.calcutta_snapshot_id
	AND cs.deleted_at IS NULL
WHERE cs.base_calcutta_id = $1::uuid
	AND cer.deleted_at IS NULL
ORDER BY cer.created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestCalcuttaEvaluationRunIDByCoreCalcuttaID(ctx context.Context, dollar_1 string) (string, error) {
	row := q.db.QueryRow(ctx, getLatestCalcuttaEvaluationRunIDByCoreCalcuttaID, dollar_1)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getLatestStrategyGenerationRunKeyByCoreCalcuttaID = `-- name: GetLatestStrategyGenerationRunKeyByCoreCalcuttaID :one
WITH srg AS (
	SELECT
		sgr.run_key
	FROM lab_gold.strategy_generation_runs sgr
	WHERE sgr.calcutta_id = $1::uuid
		AND sgr.run_key IS NOT NULL
		AND sgr.deleted_at IS NULL
),
perf AS (
	SELECT
		ep.run_id,
		MAX(ep.created_at) AS created_at
	FROM derived.entry_performance ep
	JOIN srg ON srg.run_key = ep.run_id
	WHERE ep.deleted_at IS NULL
	GROUP BY ep.run_id
)
SELECT run_id
FROM perf
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestStrategyGenerationRunKeyByCoreCalcuttaID(ctx context.Context, dollar_1 string) (string, error) {
	row := q.db.QueryRow(ctx, getLatestStrategyGenerationRunKeyByCoreCalcuttaID, dollar_1)
	var run_id string
	err := row.Scan(&run_id)
	return run_id, err
}

const getOptimizationRunsByYear = `-- name: GetOptimizationRunsByYear :many
SELECT
	COALESCE(sgr.run_key, ''::text) AS run_id,
	sgr.calcutta_id,
	COALESCE(NULLIF(sgr.optimizer_key::text, ''::text), 'legacy'::text) AS strategy,
	COALESCE(tsb.n_sims, 0)::int AS n_sims,
	COALESCE(tsb.seed, 0)::int AS seed,
	COALESCE(c.budget_points, 100)::int AS budget_points,
	sgr.created_at
FROM lab_gold.strategy_generation_runs sgr
JOIN core.calcuttas c ON c.id = sgr.calcutta_id AND c.deleted_at IS NULL
JOIN core.tournaments t ON t.id = c.tournament_id AND t.deleted_at IS NULL
JOIN core.seasons seas ON seas.id = t.season_id
LEFT JOIN derived.simulated_tournaments tsb
	ON tsb.id = sgr.simulated_tournament_id
	AND tsb.deleted_at IS NULL
WHERE sgr.deleted_at IS NULL
	AND sgr.run_key IS NOT NULL
	AND seas.year = $1::int
ORDER BY sgr.created_at DESC
`

type GetOptimizationRunsByYearRow struct {
	RunID        *string
	CalcuttaID   pgtype.UUID
	Strategy     interface{}
	NSims        int32
	Seed         int32
	BudgetPoints int32
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetOptimizationRunsByYear(ctx context.Context, dollar_1 int32) ([]GetOptimizationRunsByYearRow, error) {
	rows, err := q.db.Query(ctx, getOptimizationRunsByYear, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOptimizationRunsByYearRow
	for rows.Next() {
		var i GetOptimizationRunsByYearRow
		if err := rows.Scan(
			&i.RunID,
			&i.CalcuttaID,
			&i.Strategy,
			&i.NSims,
			&i.Seed,
			&i.BudgetPoints,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOurEntryBidsByRunID = `-- name: GetOurEntryBidsByRunID :many
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    reb.recommended_bid_points,
    reb.expected_roi
FROM lab_gold.recommended_entry_bids reb
JOIN lab_bronze.teams t ON t.id = reb.team_id
WHERE reb.run_id = $1::text
ORDER BY reb.recommended_bid_points DESC
`

type GetOurEntryBidsByRunIDRow struct {
	TeamID               string
	SchoolName           string
	Seed                 *int32
	Region               *string
	RecommendedBidPoints int32
	ExpectedRoi          float64
}

func (q *Queries) GetOurEntryBidsByRunID(ctx context.Context, dollar_1 string) ([]GetOurEntryBidsByRunIDRow, error) {
	rows, err := q.db.Query(ctx, getOurEntryBidsByRunID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOurEntryBidsByRunIDRow
	for rows.Next() {
		var i GetOurEntryBidsByRunIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.RecommendedBidPoints,
			&i.ExpectedRoi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOurEntryBidsByStrategyGenerationRunID = `-- name: GetOurEntryBidsByStrategyGenerationRunID :many
SELECT
	t.id as team_id,
	t.school_name,
	t.seed,
	t.region,
	reb.recommended_bid_points,
	reb.expected_roi
FROM lab_gold.recommended_entry_bids reb
JOIN lab_bronze.teams t ON t.id = reb.team_id
WHERE reb.strategy_generation_run_id = $1::uuid
ORDER BY reb.recommended_bid_points DESC
`

type GetOurEntryBidsByStrategyGenerationRunIDRow struct {
	TeamID               string
	SchoolName           string
	Seed                 *int32
	Region               *string
	RecommendedBidPoints int32
	ExpectedRoi          float64
}

func (q *Queries) GetOurEntryBidsByStrategyGenerationRunID(ctx context.Context, dollar_1 string) ([]GetOurEntryBidsByStrategyGenerationRunIDRow, error) {
	rows, err := q.db.Query(ctx, getOurEntryBidsByStrategyGenerationRunID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOurEntryBidsByStrategyGenerationRunIDRow
	for rows.Next() {
		var i GetOurEntryBidsByStrategyGenerationRunIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.RecommendedBidPoints,
			&i.ExpectedRoi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStrategyGenerationRunByRunKey = `-- name: GetStrategyGenerationRunByRunKey :one
SELECT
	sgr.id,
	COALESCE(sgr.run_key, ''::text) AS run_id,
	sgr.calcutta_id,
	COALESCE(NULLIF(sgr.optimizer_key::text, ''::text), 'legacy'::text) AS strategy,
	COALESCE(tsb.n_sims, 0)::int AS n_sims,
	COALESCE(tsb.seed, 0)::int AS seed,
	COALESCE(c.budget_points, 100)::int AS budget_points,
	sgr.created_at
FROM lab_gold.strategy_generation_runs sgr
LEFT JOIN core.calcuttas c
	ON c.id = sgr.calcutta_id
	AND c.deleted_at IS NULL
LEFT JOIN derived.simulated_tournaments tsb
	ON tsb.id = sgr.simulated_tournament_id
	AND tsb.deleted_at IS NULL
WHERE sgr.run_key = $1::text
	AND sgr.deleted_at IS NULL
LIMIT 1
`

type GetStrategyGenerationRunByRunKeyRow struct {
	ID           string
	RunID        *string
	CalcuttaID   pgtype.UUID
	Strategy     interface{}
	NSims        int32
	Seed         int32
	BudgetPoints int32
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetStrategyGenerationRunByRunKey(ctx context.Context, dollar_1 string) (GetStrategyGenerationRunByRunKeyRow, error) {
	row := q.db.QueryRow(ctx, getStrategyGenerationRunByRunKey, dollar_1)
	var i GetStrategyGenerationRunByRunKeyRow
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.CalcuttaID,
		&i.Strategy,
		&i.NSims,
		&i.Seed,
		&i.BudgetPoints,
		&i.CreatedAt,
	)
	return i, err
}

const getTeamPerformanceByCalcutta = `-- name: GetTeamPerformanceByCalcutta :one
WITH calcutta AS (
	SELECT
		c.id AS calcutta_id,
		c.tournament_id
	FROM core.calcuttas c
	WHERE c.id = $2::uuid
	  AND c.deleted_at IS NULL
	LIMIT 1
),
team_ctx AS (
	SELECT
		t.id AS team_id,
		bt.core_tournament_id
	FROM lab_bronze.teams t
	JOIN lab_bronze.tournaments bt ON bt.id = t.tournament_id
	WHERE t.id = $1::uuid
	LIMIT 1
),
valid AS (
	SELECT 1
	FROM calcutta c
	JOIN team_ctx tc ON tc.core_tournament_id = c.tournament_id
	LIMIT 1
),
round_distribution AS (
	SELECT
		st.team_id,
		CASE (st.wins + st.byes)
			WHEN 0 THEN 'R64'
			WHEN 1 THEN 'R64'
			WHEN 2 THEN 'R32'
			WHEN 3 THEN 'S16'
			WHEN 4 THEN 'E8'
			WHEN 5 THEN 'F4'
			WHEN 6 THEN 'Finals'
			WHEN 7 THEN 'Champion'
			ELSE 'Unknown'
		END as round_name,
		COUNT(*)::int as count
	FROM derived.simulated_teams st
	WHERE st.team_id = $1::uuid
	GROUP BY st.team_id, round_name
)
SELECT
	t.id as team_id,
	t.school_name,
	t.seed,
	t.region,
	t.kenpom_net,
	COUNT(DISTINCT st.sim_id)::int as total_sims,
	AVG(st.wins)::float as avg_wins,
	AVG(core.calcutta_points_for_progress((SELECT calcutta_id FROM calcutta), st.wins, st.byes))::float as avg_points,
	jsonb_object_agg(rd.round_name, rd.count) as round_distribution
FROM lab_bronze.teams t
JOIN valid v ON true

JOIN derived.simulated_teams st ON st.team_id = t.id
	LEFT JOIN round_distribution rd ON rd.team_id = t.id
WHERE t.id = $1::uuid
GROUP BY t.id, t.school_name, t.seed, t.region, t.kenpom_net
`

type GetTeamPerformanceByCalcuttaParams struct {
	TeamID     string
	CalcuttaID string
}

type GetTeamPerformanceByCalcuttaRow struct {
	TeamID            string
	SchoolName        string
	Seed              *int32
	Region            *string
	KenpomNet         *float64
	TotalSims         int32
	AvgWins           float64
	AvgPoints         float64
	RoundDistribution []byte
}

func (q *Queries) GetTeamPerformanceByCalcutta(ctx context.Context, arg GetTeamPerformanceByCalcuttaParams) (GetTeamPerformanceByCalcuttaRow, error) {
	row := q.db.QueryRow(ctx, getTeamPerformanceByCalcutta, arg.TeamID, arg.CalcuttaID)
	var i GetTeamPerformanceByCalcuttaRow
	err := row.Scan(
		&i.TeamID,
		&i.SchoolName,
		&i.Seed,
		&i.Region,
		&i.KenpomNet,
		&i.TotalSims,
		&i.AvgWins,
		&i.AvgPoints,
		&i.RoundDistribution,
	)
	return i, err
}

const getTeamPerformanceByID = `-- name: GetTeamPerformanceByID :one
WITH season_ctx AS (
    SELECT bt.core_tournament_id
    FROM lab_bronze.teams t
    JOIN lab_bronze.tournaments bt ON bt.id = t.tournament_id
    WHERE t.id = $1::uuid
    LIMIT 1
),
main_tournament AS (
    SELECT tr.id
    FROM core.tournaments tr
    JOIN season_ctx sc ON tr.id = sc.core_tournament_id
    WHERE tr.deleted_at IS NULL
    ORDER BY tr.created_at DESC
    LIMIT 1
),
calcutta_ctx AS (
    SELECT c.id AS calcutta_id
    FROM core.calcuttas c
    JOIN main_tournament mt ON mt.id = c.tournament_id
    WHERE c.deleted_at IS NULL
    ORDER BY c.created_at DESC
    LIMIT 1
),
round_distribution AS (
    SELECT 
        st.team_id,
        CASE (st.wins + st.byes)
            WHEN 0 THEN 'R64'
            WHEN 1 THEN 'R64'
            WHEN 2 THEN 'R32'
            WHEN 3 THEN 'S16'
            WHEN 4 THEN 'E8'
            WHEN 5 THEN 'F4'
            WHEN 6 THEN 'Finals'
            WHEN 7 THEN 'Champion'
            ELSE 'Unknown'
        END as round_name,
        COUNT(*)::int as count
    FROM derived.simulated_teams st
    JOIN lab_bronze.teams t ON t.id = st.team_id
    WHERE st.team_id = $1::uuid
    GROUP BY st.team_id, round_name
)
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    t.kenpom_net,
    COUNT(DISTINCT st.sim_id)::int as total_sims,
    AVG(st.wins)::float as avg_wins,
    AVG(
        CASE
            WHEN (SELECT calcutta_id FROM calcutta_ctx) IS NULL THEN 0
            ELSE core.calcutta_points_for_progress((SELECT calcutta_id FROM calcutta_ctx), st.wins, st.byes)
        END
    )::float as avg_points,
    jsonb_object_agg(rd.round_name, rd.count) as round_distribution
FROM lab_bronze.teams t
JOIN derived.simulated_teams st ON st.team_id = t.id
LEFT JOIN round_distribution rd ON rd.team_id = t.id
WHERE t.id = $1::uuid
GROUP BY t.id, t.school_name, t.seed, t.region, t.kenpom_net
`

type GetTeamPerformanceByIDRow struct {
	TeamID            string
	SchoolName        string
	Seed              *int32
	Region            *string
	KenpomNet         *float64
	TotalSims         int32
	AvgWins           float64
	AvgPoints         float64
	RoundDistribution []byte
}

func (q *Queries) GetTeamPerformanceByID(ctx context.Context, dollar_1 string) (GetTeamPerformanceByIDRow, error) {
	row := q.db.QueryRow(ctx, getTeamPerformanceByID, dollar_1)
	var i GetTeamPerformanceByIDRow
	err := row.Scan(
		&i.TeamID,
		&i.SchoolName,
		&i.Seed,
		&i.Region,
		&i.KenpomNet,
		&i.TotalSims,
		&i.AvgWins,
		&i.AvgPoints,
		&i.RoundDistribution,
	)
	return i, err
}

const getTeamPredictionsByYear = `-- name: GetTeamPredictionsByYear :many
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    t.kenpom_net
FROM lab_bronze.teams t
JOIN lab_bronze.tournaments bt ON bt.id = t.tournament_id
WHERE bt.season = $1::int
ORDER BY t.seed
`

type GetTeamPredictionsByYearRow struct {
	TeamID     string
	SchoolName string
	Seed       *int32
	Region     *string
	KenpomNet  *float64
}

func (q *Queries) GetTeamPredictionsByYear(ctx context.Context, dollar_1 int32) ([]GetTeamPredictionsByYearRow, error) {
	rows, err := q.db.Query(ctx, getTeamPredictionsByYear, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamPredictionsByYearRow
	for rows.Next() {
		var i GetTeamPredictionsByYearRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.KenpomNet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentSimStatsByCoreTournamentID = `-- name: GetTournamentSimStatsByCoreTournamentID :one
WITH tournament_info AS (
	SELECT
		bt.id as tournament_id,
		bt.season
	FROM lab_bronze.tournaments bt
	WHERE bt.core_tournament_id = $1::uuid
	LIMIT 1
),
sim_stats AS (
	SELECT
		COUNT(DISTINCT sim_id)::int as total_simulations,
		COUNT(DISTINCT team_id)::int as total_teams
	FROM derived.simulated_teams st
	JOIN tournament_info ti ON st.tournament_id = ti.tournament_id
),
prediction_stats AS (
	SELECT COUNT(*)::int as total_predictions
	FROM lab_silver.predicted_game_outcomes pgo
	JOIN tournament_info ti ON pgo.tournament_id = ti.tournament_id
),
win_stats AS (
	SELECT
		AVG(wins)::double precision as mean_wins,
		PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY wins)::double precision as median_wins,
		MAX(wins)::int as max_wins
	FROM derived.simulated_teams st
	JOIN tournament_info ti ON st.tournament_id = ti.tournament_id
)
SELECT
	ti.tournament_id,
	ti.season,
	COALESCE(ss.total_simulations, 0)::int as total_simulations,
	COALESCE(ps.total_predictions, 0)::int as total_predictions,
	COALESCE(ws.mean_wins, 0.0)::double precision as mean_wins,
	COALESCE(ws.median_wins, 0.0)::double precision as median_wins,
	COALESCE(ws.max_wins, 0)::int as max_wins,
	NOW()::timestamptz as last_updated
FROM tournament_info ti
LEFT JOIN sim_stats ss ON true
LEFT JOIN prediction_stats ps ON true
LEFT JOIN win_stats ws ON true
`

type GetTournamentSimStatsByCoreTournamentIDRow struct {
	TournamentID     string
	Season           int32
	TotalSimulations int32
	TotalPredictions int32
	MeanWins         float64
	MedianWins       float64
	MaxWins          int32
	LastUpdated      pgtype.Timestamptz
}

func (q *Queries) GetTournamentSimStatsByCoreTournamentID(ctx context.Context, coreTournamentID string) (GetTournamentSimStatsByCoreTournamentIDRow, error) {
	row := q.db.QueryRow(ctx, getTournamentSimStatsByCoreTournamentID, coreTournamentID)
	var i GetTournamentSimStatsByCoreTournamentIDRow
	err := row.Scan(
		&i.TournamentID,
		&i.Season,
		&i.TotalSimulations,
		&i.TotalPredictions,
		&i.MeanWins,
		&i.MedianWins,
		&i.MaxWins,
		&i.LastUpdated,
	)
	return i, err
}

const getTournamentSimStatsByYear = `-- name: GetTournamentSimStatsByYear :one

SELECT 
    t.id as tournament_id,
    t.season,
    COUNT(DISTINCT st.sim_id)::int as n_sims,
    COUNT(DISTINCT st.team_id)::int as n_teams,
    AVG(st.wins + st.byes)::float as avg_progress,
    MAX(st.wins + st.byes)::int as max_progress
FROM lab_bronze.tournaments t
JOIN derived.simulated_teams st ON t.id = st.tournament_id
WHERE t.season = $1::int
GROUP BY t.id, t.season
`

type GetTournamentSimStatsByYearRow struct {
	TournamentID string
	Season       int32
	NSims        int32
	NTeams       int32
	AvgProgress  float64
	MaxProgress  int32
}

// ML Analytics Queries
// For tournament simulation and entry evaluation data
func (q *Queries) GetTournamentSimStatsByYear(ctx context.Context, dollar_1 int32) (GetTournamentSimStatsByYearRow, error) {
	row := q.db.QueryRow(ctx, getTournamentSimStatsByYear, dollar_1)
	var i GetTournamentSimStatsByYearRow
	err := row.Scan(
		&i.TournamentID,
		&i.Season,
		&i.NSims,
		&i.NTeams,
		&i.AvgProgress,
		&i.MaxProgress,
	)
	return i, err
}

const listCalcuttaEvaluationRunsByCoreCalcuttaID = `-- name: ListCalcuttaEvaluationRunsByCoreCalcuttaID :many
SELECT
	cer.id,
	cer.simulated_tournament_id,
	cer.calcutta_snapshot_id,
	cer.purpose,
	cer.created_at
FROM derived.calcutta_evaluation_runs cer
JOIN core.calcutta_snapshots cs
	ON cs.id = cer.calcutta_snapshot_id
	AND cs.deleted_at IS NULL
WHERE cs.base_calcutta_id = $1::uuid
	AND cer.deleted_at IS NULL
ORDER BY cer.created_at DESC
`

type ListCalcuttaEvaluationRunsByCoreCalcuttaIDRow struct {
	ID                    string
	SimulatedTournamentID string
	CalcuttaSnapshotID    pgtype.UUID
	Purpose               string
	CreatedAt             pgtype.Timestamptz
}

func (q *Queries) ListCalcuttaEvaluationRunsByCoreCalcuttaID(ctx context.Context, dollar_1 string) ([]ListCalcuttaEvaluationRunsByCoreCalcuttaIDRow, error) {
	rows, err := q.db.Query(ctx, listCalcuttaEvaluationRunsByCoreCalcuttaID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCalcuttaEvaluationRunsByCoreCalcuttaIDRow
	for rows.Next() {
		var i ListCalcuttaEvaluationRunsByCoreCalcuttaIDRow
		if err := rows.Scan(
			&i.ID,
			&i.SimulatedTournamentID,
			&i.CalcuttaSnapshotID,
			&i.Purpose,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStrategyGenerationRunsByCoreCalcuttaID = `-- name: ListStrategyGenerationRunsByCoreCalcuttaID :many
SELECT
	sgr.id,
	sgr.run_key,
	sgr.simulated_tournament_id,
	sgr.calcutta_id,
	sgr.purpose,
	sgr.returns_model_key,
	sgr.investment_model_key,
	sgr.optimizer_key,
	sgr.params_json,
	sgr.git_sha,
	sgr.created_at
FROM lab_gold.strategy_generation_runs sgr
WHERE sgr.calcutta_id = $1::uuid
	AND sgr.deleted_at IS NULL
ORDER BY sgr.created_at DESC
`

type ListStrategyGenerationRunsByCoreCalcuttaIDRow struct {
	ID                    string
	RunKey                *string
	SimulatedTournamentID pgtype.UUID
	CalcuttaID            pgtype.UUID
	Purpose               string
	ReturnsModelKey       string
	InvestmentModelKey    string
	OptimizerKey          string
	ParamsJson            []byte
	GitSha                *string
	CreatedAt             pgtype.Timestamptz
}

func (q *Queries) ListStrategyGenerationRunsByCoreCalcuttaID(ctx context.Context, dollar_1 string) ([]ListStrategyGenerationRunsByCoreCalcuttaIDRow, error) {
	rows, err := q.db.Query(ctx, listStrategyGenerationRunsByCoreCalcuttaID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStrategyGenerationRunsByCoreCalcuttaIDRow
	for rows.Next() {
		var i ListStrategyGenerationRunsByCoreCalcuttaIDRow
		if err := rows.Scan(
			&i.ID,
			&i.RunKey,
			&i.SimulatedTournamentID,
			&i.CalcuttaID,
			&i.Purpose,
			&i.ReturnsModelKey,
			&i.InvestmentModelKey,
			&i.OptimizerKey,
			&i.ParamsJson,
			&i.GitSha,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournamentSimulationBatchesByCoreTournamentID = `-- name: ListTournamentSimulationBatchesByCoreTournamentID :many
SELECT
	b.id,
	b.tournament_id,
	b.simulation_state_id,
	b.n_sims,
	b.seed,
	b.probability_source_key,
	b.created_at
FROM derived.simulated_tournaments b
WHERE b.tournament_id = $1::uuid
	AND b.deleted_at IS NULL
ORDER BY b.created_at DESC
`

type ListTournamentSimulationBatchesByCoreTournamentIDRow struct {
	ID                   string
	TournamentID         string
	SimulationStateID    string
	NSims                int32
	Seed                 int32
	ProbabilitySourceKey string
	CreatedAt            pgtype.Timestamptz
}

func (q *Queries) ListTournamentSimulationBatchesByCoreTournamentID(ctx context.Context, dollar_1 string) ([]ListTournamentSimulationBatchesByCoreTournamentIDRow, error) {
	rows, err := q.db.Query(ctx, listTournamentSimulationBatchesByCoreTournamentID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTournamentSimulationBatchesByCoreTournamentIDRow
	for rows.Next() {
		var i ListTournamentSimulationBatchesByCoreTournamentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.TournamentID,
			&i.SimulationStateID,
			&i.NSims,
			&i.Seed,
			&i.ProbabilitySourceKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
