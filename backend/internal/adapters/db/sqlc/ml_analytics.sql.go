// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ml_analytics.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActualEntryPortfolio = `-- name: GetActualEntryPortfolio :many
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    eb.bid_amount_points
FROM lab_bronze.entry_bids eb
JOIN lab_bronze.teams t ON eb.team_id = t.id
JOIN lab_gold.optimization_runs r ON eb.calcutta_id = r.calcutta_id
WHERE r.run_id = $1 AND eb.entry_name = $2
ORDER BY eb.bid_amount_points DESC
`

type GetActualEntryPortfolioParams struct {
	RunID     string
	EntryName string
}

type GetActualEntryPortfolioRow struct {
	TeamID          string
	SchoolName      string
	Seed            *int32
	Region          *string
	BidAmountPoints int32
}

// For actual entries from the auction
func (q *Queries) GetActualEntryPortfolio(ctx context.Context, arg GetActualEntryPortfolioParams) ([]GetActualEntryPortfolioRow, error) {
	rows, err := q.db.Query(ctx, getActualEntryPortfolio, arg.RunID, arg.EntryName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActualEntryPortfolioRow
	for rows.Next() {
		var i GetActualEntryPortfolioRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidAmountPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryPerformanceByRunID = `-- name: GetEntryPerformanceByRunID :many
SELECT
    ROW_NUMBER() OVER (ORDER BY gep.mean_payout DESC)::int as rank,
    gep.entry_name,
    COALESCE(gep.mean_payout, 0.0)::double precision as mean_payout,
    COALESCE(gep.median_payout, 0.0)::double precision as median_payout,
    COALESCE(gep.p_top1, 0.0)::double precision as p_top1,
    COALESCE(gep.p_in_money, 0.0)::double precision as p_in_money,
    (
        SELECT COUNT(*)::int
        FROM analytics.entry_simulation_outcomes eso
        WHERE eso.run_id = $1::text AND eso.entry_name = gep.entry_name
    ) as total_simulations
FROM analytics.entry_performance gep
WHERE gep.run_id = $1::text
ORDER BY gep.mean_payout DESC
`

type GetEntryPerformanceByRunIDRow struct {
	Rank             int32
	EntryName        string
	MeanPayout       float64
	MedianPayout     float64
	PTop1            float64
	PInMoney         float64
	TotalSimulations int32
}

func (q *Queries) GetEntryPerformanceByRunID(ctx context.Context, dollar_1 string) ([]GetEntryPerformanceByRunIDRow, error) {
	rows, err := q.db.Query(ctx, getEntryPerformanceByRunID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryPerformanceByRunIDRow
	for rows.Next() {
		var i GetEntryPerformanceByRunIDRow
		if err := rows.Scan(
			&i.Rank,
			&i.EntryName,
			&i.MeanPayout,
			&i.MedianPayout,
			&i.PTop1,
			&i.PInMoney,
			&i.TotalSimulations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryPortfolio = `-- name: GetEntryPortfolio :many




SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    reb.recommended_bid_points as bid_amount
FROM lab_gold.recommended_entry_bids reb
JOIN lab_bronze.teams t ON reb.team_id = t.id
WHERE reb.run_id = $1
ORDER BY reb.recommended_bid_points DESC
`

type GetEntryPortfolioRow struct {
	TeamID     string
	SchoolName string
	Seed       *int32
	Region     *string
	BidAmount  int32
}

// Removed - table doesn't exist in new schema
// Removed - view doesn't exist in new schema
// Removed - table schema changed
// Removed - table schema changed
// For our strategy entry
func (q *Queries) GetEntryPortfolio(ctx context.Context, runID string) ([]GetEntryPortfolioRow, error) {
	rows, err := q.db.Query(ctx, getEntryPortfolio, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryPortfolioRow
	for rows.Next() {
		var i GetEntryPortfolioRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestOptimizationRunIDByCoreCalcuttaID = `-- name: GetLatestOptimizationRunIDByCoreCalcuttaID :one
SELECT gor.run_id
FROM lab_gold.optimization_runs gor
JOIN lab_bronze.calcuttas bc ON bc.id = gor.calcutta_id
WHERE bc.core_calcutta_id = $1::uuid
ORDER BY gor.created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestOptimizationRunIDByCoreCalcuttaID(ctx context.Context, dollar_1 string) (string, error) {
	row := q.db.QueryRow(ctx, getLatestOptimizationRunIDByCoreCalcuttaID, dollar_1)
	var run_id string
	err := row.Scan(&run_id)
	return run_id, err
}

const getOptimizationRunByID = `-- name: GetOptimizationRunByID :one
SELECT 
    run_id,
    calcutta_id,
    strategy,
    n_sims,
    seed,
    budget_points,
    created_at
FROM lab_gold.optimization_runs
WHERE run_id = $1::text
`

type GetOptimizationRunByIDRow struct {
	RunID        string
	CalcuttaID   pgtype.UUID
	Strategy     string
	NSims        int32
	Seed         int32
	BudgetPoints int32
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetOptimizationRunByID(ctx context.Context, dollar_1 string) (GetOptimizationRunByIDRow, error) {
	row := q.db.QueryRow(ctx, getOptimizationRunByID, dollar_1)
	var i GetOptimizationRunByIDRow
	err := row.Scan(
		&i.RunID,
		&i.CalcuttaID,
		&i.Strategy,
		&i.NSims,
		&i.Seed,
		&i.BudgetPoints,
		&i.CreatedAt,
	)
	return i, err
}

const getOptimizationRunsByYear = `-- name: GetOptimizationRunsByYear :many
SELECT 
    r.run_id,
    r.calcutta_id,
    r.strategy,
    r.n_sims,
    r.seed,
    r.budget_points,
    r.created_at
FROM lab_gold.optimization_runs r
JOIN lab_bronze.calcuttas bc ON bc.id = r.calcutta_id
JOIN lab_bronze.tournaments bt ON bt.id = bc.tournament_id
WHERE bt.season = $1::int
ORDER BY r.created_at DESC
`

type GetOptimizationRunsByYearRow struct {
	RunID        string
	CalcuttaID   pgtype.UUID
	Strategy     string
	NSims        int32
	Seed         int32
	BudgetPoints int32
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetOptimizationRunsByYear(ctx context.Context, dollar_1 int32) ([]GetOptimizationRunsByYearRow, error) {
	rows, err := q.db.Query(ctx, getOptimizationRunsByYear, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOptimizationRunsByYearRow
	for rows.Next() {
		var i GetOptimizationRunsByYearRow
		if err := rows.Scan(
			&i.RunID,
			&i.CalcuttaID,
			&i.Strategy,
			&i.NSims,
			&i.Seed,
			&i.BudgetPoints,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOurEntryBidsByRunID = `-- name: GetOurEntryBidsByRunID :many
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    reb.recommended_bid_points,
    reb.expected_roi
FROM lab_gold.recommended_entry_bids reb
JOIN lab_bronze.teams t ON t.id = reb.team_id
WHERE reb.run_id = $1::text
ORDER BY reb.recommended_bid_points DESC
`

type GetOurEntryBidsByRunIDRow struct {
	TeamID               string
	SchoolName           string
	Seed                 *int32
	Region               *string
	RecommendedBidPoints int32
	ExpectedRoi          float64
}

func (q *Queries) GetOurEntryBidsByRunID(ctx context.Context, dollar_1 string) ([]GetOurEntryBidsByRunIDRow, error) {
	rows, err := q.db.Query(ctx, getOurEntryBidsByRunID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOurEntryBidsByRunIDRow
	for rows.Next() {
		var i GetOurEntryBidsByRunIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.RecommendedBidPoints,
			&i.ExpectedRoi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamPerformanceByCalcutta = `-- name: GetTeamPerformanceByCalcutta :one
WITH calcutta AS (
	SELECT
		c.id AS calcutta_id,
		c.tournament_id
	FROM core.calcuttas c
	WHERE c.id = $2::uuid
	  AND c.deleted_at IS NULL
	LIMIT 1
),
team_ctx AS (
	SELECT
		t.id AS team_id,
		bt.core_tournament_id
	FROM lab_bronze.teams t
	JOIN lab_bronze.tournaments bt ON bt.id = t.tournament_id
	WHERE t.id = $1::uuid
	LIMIT 1
),
valid AS (
	SELECT 1
	FROM calcutta c
	JOIN team_ctx tc ON tc.core_tournament_id = c.tournament_id
	LIMIT 1
),
round_distribution AS (
	SELECT
		st.team_id,
		CASE (st.wins + st.byes)
			WHEN 0 THEN 'R64'
			WHEN 1 THEN 'R64'
			WHEN 2 THEN 'R32'
			WHEN 3 THEN 'S16'
			WHEN 4 THEN 'E8'
			WHEN 5 THEN 'F4'
			WHEN 6 THEN 'Finals'
			WHEN 7 THEN 'Champion'
			ELSE 'Unknown'
		END as round_name,
		COUNT(*)::int as count
	FROM analytics.simulated_tournaments st
	WHERE st.team_id = $1::uuid
	GROUP BY st.team_id, round_name
)
SELECT
	t.id as team_id,
	t.school_name,
	t.seed,
	t.region,
	t.kenpom_net,
	COUNT(DISTINCT st.sim_id)::int as total_sims,
	AVG(st.wins)::float as avg_wins,
	AVG(core.calcutta_points_for_progress((SELECT calcutta_id FROM calcutta), st.wins, st.byes))::float as avg_points,
	jsonb_object_agg(rd.round_name, rd.count) as round_distribution
FROM lab_bronze.teams t
JOIN valid v ON true

JOIN analytics.simulated_tournaments st ON st.team_id = t.id
	LEFT JOIN round_distribution rd ON rd.team_id = t.id
WHERE t.id = $1::uuid
GROUP BY t.id, t.school_name, t.seed, t.region, t.kenpom_net
`

type GetTeamPerformanceByCalcuttaParams struct {
	TeamID     string
	CalcuttaID string
}

type GetTeamPerformanceByCalcuttaRow struct {
	TeamID            string
	SchoolName        string
	Seed              *int32
	Region            *string
	KenpomNet         *float64
	TotalSims         int32
	AvgWins           float64
	AvgPoints         float64
	RoundDistribution []byte
}

func (q *Queries) GetTeamPerformanceByCalcutta(ctx context.Context, arg GetTeamPerformanceByCalcuttaParams) (GetTeamPerformanceByCalcuttaRow, error) {
	row := q.db.QueryRow(ctx, getTeamPerformanceByCalcutta, arg.TeamID, arg.CalcuttaID)
	var i GetTeamPerformanceByCalcuttaRow
	err := row.Scan(
		&i.TeamID,
		&i.SchoolName,
		&i.Seed,
		&i.Region,
		&i.KenpomNet,
		&i.TotalSims,
		&i.AvgWins,
		&i.AvgPoints,
		&i.RoundDistribution,
	)
	return i, err
}

const getTeamPerformanceByID = `-- name: GetTeamPerformanceByID :one
WITH season_ctx AS (
    SELECT bt.core_tournament_id
    FROM lab_bronze.teams t
    JOIN lab_bronze.tournaments bt ON bt.id = t.tournament_id
    WHERE t.id = $1::uuid
    LIMIT 1
),
main_tournament AS (
    SELECT tr.id
    FROM core.tournaments tr
    JOIN season_ctx sc ON tr.id = sc.core_tournament_id
    WHERE tr.deleted_at IS NULL
    ORDER BY tr.created_at DESC
    LIMIT 1
),
calcutta_ctx AS (
    SELECT c.id AS calcutta_id
    FROM core.calcuttas c
    JOIN main_tournament mt ON mt.id = c.tournament_id
    WHERE c.deleted_at IS NULL
    ORDER BY c.created_at DESC
    LIMIT 1
),
round_distribution AS (
    SELECT 
        st.team_id,
        CASE (st.wins + st.byes)
            WHEN 0 THEN 'R64'
            WHEN 1 THEN 'R64'
            WHEN 2 THEN 'R32'
            WHEN 3 THEN 'S16'
            WHEN 4 THEN 'E8'
            WHEN 5 THEN 'F4'
            WHEN 6 THEN 'Finals'
            WHEN 7 THEN 'Champion'
            ELSE 'Unknown'
        END as round_name,
        COUNT(*)::int as count
    FROM analytics.simulated_tournaments st
    JOIN lab_bronze.teams t ON t.id = st.team_id
    WHERE st.team_id = $1::uuid
    GROUP BY st.team_id, round_name
)
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    t.kenpom_net,
    COUNT(DISTINCT st.sim_id)::int as total_sims,
    AVG(st.wins)::float as avg_wins,
    AVG(
        CASE
            WHEN (SELECT calcutta_id FROM calcutta_ctx) IS NULL THEN 0
            ELSE core.calcutta_points_for_progress((SELECT calcutta_id FROM calcutta_ctx), st.wins, st.byes)
        END
    )::float as avg_points,
    jsonb_object_agg(rd.round_name, rd.count) as round_distribution
FROM lab_bronze.teams t
JOIN analytics.simulated_tournaments st ON st.team_id = t.id
LEFT JOIN round_distribution rd ON rd.team_id = t.id
WHERE t.id = $1::uuid
GROUP BY t.id, t.school_name, t.seed, t.region, t.kenpom_net
`

type GetTeamPerformanceByIDRow struct {
	TeamID            string
	SchoolName        string
	Seed              *int32
	Region            *string
	KenpomNet         *float64
	TotalSims         int32
	AvgWins           float64
	AvgPoints         float64
	RoundDistribution []byte
}

func (q *Queries) GetTeamPerformanceByID(ctx context.Context, dollar_1 string) (GetTeamPerformanceByIDRow, error) {
	row := q.db.QueryRow(ctx, getTeamPerformanceByID, dollar_1)
	var i GetTeamPerformanceByIDRow
	err := row.Scan(
		&i.TeamID,
		&i.SchoolName,
		&i.Seed,
		&i.Region,
		&i.KenpomNet,
		&i.TotalSims,
		&i.AvgWins,
		&i.AvgPoints,
		&i.RoundDistribution,
	)
	return i, err
}

const getTeamPredictionsByYear = `-- name: GetTeamPredictionsByYear :many
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    t.kenpom_net
FROM lab_bronze.teams t
JOIN lab_bronze.tournaments bt ON bt.id = t.tournament_id
WHERE bt.season = $1::int
ORDER BY t.seed
`

type GetTeamPredictionsByYearRow struct {
	TeamID     string
	SchoolName string
	Seed       *int32
	Region     *string
	KenpomNet  *float64
}

func (q *Queries) GetTeamPredictionsByYear(ctx context.Context, dollar_1 int32) ([]GetTeamPredictionsByYearRow, error) {
	rows, err := q.db.Query(ctx, getTeamPredictionsByYear, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamPredictionsByYearRow
	for rows.Next() {
		var i GetTeamPredictionsByYearRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.KenpomNet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentSimStatsByCoreTournamentID = `-- name: GetTournamentSimStatsByCoreTournamentID :one
WITH tournament_info AS (
	SELECT
		bt.id as tournament_id,
		bt.season
	FROM lab_bronze.tournaments bt
	WHERE bt.core_tournament_id = $1::uuid
	LIMIT 1
),
sim_stats AS (
	SELECT
		COUNT(DISTINCT sim_id)::int as total_simulations,
		COUNT(DISTINCT team_id)::int as total_teams
	FROM analytics.simulated_tournaments st
	JOIN tournament_info ti ON st.tournament_id = ti.tournament_id
),
prediction_stats AS (
	SELECT COUNT(*)::int as total_predictions
	FROM lab_silver.predicted_game_outcomes pgo
	JOIN tournament_info ti ON pgo.tournament_id = ti.tournament_id
),
win_stats AS (
	SELECT
		AVG(wins)::double precision as mean_wins,
		PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY wins)::double precision as median_wins,
		MAX(wins)::int as max_wins
	FROM analytics.simulated_tournaments st
	JOIN tournament_info ti ON st.tournament_id = ti.tournament_id
)
SELECT
	ti.tournament_id,
	ti.season,
	COALESCE(ss.total_simulations, 0)::int as total_simulations,
	COALESCE(ps.total_predictions, 0)::int as total_predictions,
	COALESCE(ws.mean_wins, 0.0)::double precision as mean_wins,
	COALESCE(ws.median_wins, 0.0)::double precision as median_wins,
	COALESCE(ws.max_wins, 0)::int as max_wins,
	NOW()::timestamptz as last_updated
FROM tournament_info ti
LEFT JOIN sim_stats ss ON true
LEFT JOIN prediction_stats ps ON true
LEFT JOIN win_stats ws ON true
`

type GetTournamentSimStatsByCoreTournamentIDRow struct {
	TournamentID     string
	Season           int32
	TotalSimulations int32
	TotalPredictions int32
	MeanWins         float64
	MedianWins       float64
	MaxWins          int32
	LastUpdated      pgtype.Timestamptz
}

func (q *Queries) GetTournamentSimStatsByCoreTournamentID(ctx context.Context, coreTournamentID string) (GetTournamentSimStatsByCoreTournamentIDRow, error) {
	row := q.db.QueryRow(ctx, getTournamentSimStatsByCoreTournamentID, coreTournamentID)
	var i GetTournamentSimStatsByCoreTournamentIDRow
	err := row.Scan(
		&i.TournamentID,
		&i.Season,
		&i.TotalSimulations,
		&i.TotalPredictions,
		&i.MeanWins,
		&i.MedianWins,
		&i.MaxWins,
		&i.LastUpdated,
	)
	return i, err
}

const getTournamentSimStatsByYear = `-- name: GetTournamentSimStatsByYear :one

SELECT 
    t.id as tournament_id,
    t.season,
    COUNT(DISTINCT st.sim_id)::int as n_sims,
    COUNT(DISTINCT st.team_id)::int as n_teams,
    AVG(st.wins + st.byes)::float as avg_progress,
    MAX(st.wins + st.byes)::int as max_progress
FROM lab_bronze.tournaments t
JOIN analytics.simulated_tournaments st ON t.id = st.tournament_id
WHERE t.season = $1::int
GROUP BY t.id, t.season
`

type GetTournamentSimStatsByYearRow struct {
	TournamentID string
	Season       int32
	NSims        int32
	NTeams       int32
	AvgProgress  float64
	MaxProgress  int32
}

// ML Analytics Queries
// For tournament simulation and entry evaluation data
func (q *Queries) GetTournamentSimStatsByYear(ctx context.Context, dollar_1 int32) (GetTournamentSimStatsByYearRow, error) {
	row := q.db.QueryRow(ctx, getTournamentSimStatsByYear, dollar_1)
	var i GetTournamentSimStatsByYearRow
	err := row.Scan(
		&i.TournamentID,
		&i.Season,
		&i.NSims,
		&i.NTeams,
		&i.AvgProgress,
		&i.MaxProgress,
	)
	return i, err
}
