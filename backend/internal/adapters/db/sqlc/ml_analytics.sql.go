// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ml_analytics.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActualEntryPortfolio = `-- name: GetActualEntryPortfolio :many
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    eb.bid_amount_points
FROM bronze_entry_bids eb
JOIN bronze_teams t ON eb.team_id = t.id
JOIN gold_optimization_runs r ON eb.calcutta_id = r.calcutta_id
WHERE r.run_id = $1 AND eb.entry_name = $2
ORDER BY eb.bid_amount_points DESC
`

type GetActualEntryPortfolioParams struct {
	RunID     string
	EntryName string
}

type GetActualEntryPortfolioRow struct {
	TeamID          int64
	SchoolName      string
	Seed            int32
	Region          string
	BidAmountPoints int32
}

// For actual entries from the auction
func (q *Queries) GetActualEntryPortfolio(ctx context.Context, arg GetActualEntryPortfolioParams) ([]GetActualEntryPortfolioRow, error) {
	rows, err := q.db.Query(ctx, getActualEntryPortfolio, arg.RunID, arg.EntryName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActualEntryPortfolioRow
	for rows.Next() {
		var i GetActualEntryPortfolioRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidAmountPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntryPortfolio = `-- name: GetEntryPortfolio :many




SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    reb.recommended_bid_points as bid_amount
FROM gold_recommended_entry_bids reb
JOIN bronze_teams t ON reb.team_id = t.id
WHERE reb.run_id = $1
ORDER BY reb.recommended_bid_points DESC
`

type GetEntryPortfolioRow struct {
	TeamID     int64
	SchoolName string
	Seed       int32
	Region     string
	BidAmount  int32
}

// Removed - table doesn't exist in new schema
// Removed - view doesn't exist in new schema
// Removed - table schema changed
// Removed - table schema changed
// For our strategy entry
func (q *Queries) GetEntryPortfolio(ctx context.Context, runID string) ([]GetEntryPortfolioRow, error) {
	rows, err := q.db.Query(ctx, getEntryPortfolio, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntryPortfolioRow
	for rows.Next() {
		var i GetEntryPortfolioRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.BidAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptimizationRunByID = `-- name: GetOptimizationRunByID :one
SELECT 
    run_id,
    calcutta_id,
    strategy,
    n_sims,
    seed,
    budget_points,
    created_at
FROM gold_optimization_runs
WHERE run_id = $1::text
`

type GetOptimizationRunByIDRow struct {
	RunID        string
	CalcuttaID   int64
	Strategy     string
	NSims        int32
	Seed         int32
	BudgetPoints int32
	CreatedAt    pgtype.Timestamp
}

func (q *Queries) GetOptimizationRunByID(ctx context.Context, dollar_1 string) (GetOptimizationRunByIDRow, error) {
	row := q.db.QueryRow(ctx, getOptimizationRunByID, dollar_1)
	var i GetOptimizationRunByIDRow
	err := row.Scan(
		&i.RunID,
		&i.CalcuttaID,
		&i.Strategy,
		&i.NSims,
		&i.Seed,
		&i.BudgetPoints,
		&i.CreatedAt,
	)
	return i, err
}

const getOptimizationRunsByYear = `-- name: GetOptimizationRunsByYear :many
SELECT 
    r.run_id,
    r.calcutta_id,
    r.strategy,
    r.n_sims,
    r.seed,
    r.budget_points,
    r.created_at
FROM gold_optimization_runs r
JOIN bronze_calcuttas bc ON bc.id = r.calcutta_id
JOIN bronze_tournaments bt ON bt.id = bc.tournament_id
WHERE bt.season = $1::int
ORDER BY r.created_at DESC
`

type GetOptimizationRunsByYearRow struct {
	RunID        string
	CalcuttaID   int64
	Strategy     string
	NSims        int32
	Seed         int32
	BudgetPoints int32
	CreatedAt    pgtype.Timestamp
}

func (q *Queries) GetOptimizationRunsByYear(ctx context.Context, dollar_1 int32) ([]GetOptimizationRunsByYearRow, error) {
	rows, err := q.db.Query(ctx, getOptimizationRunsByYear, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOptimizationRunsByYearRow
	for rows.Next() {
		var i GetOptimizationRunsByYearRow
		if err := rows.Scan(
			&i.RunID,
			&i.CalcuttaID,
			&i.Strategy,
			&i.NSims,
			&i.Seed,
			&i.BudgetPoints,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOurEntryBidsByRunID = `-- name: GetOurEntryBidsByRunID :many
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    reb.recommended_bid_points,
    reb.expected_roi
FROM gold_recommended_entry_bids reb
JOIN bronze_teams t ON t.id = reb.team_id
WHERE reb.run_id = $1::text
ORDER BY reb.recommended_bid_points DESC
`

type GetOurEntryBidsByRunIDRow struct {
	TeamID               int64
	SchoolName           string
	Seed                 int32
	Region               string
	RecommendedBidPoints int32
	ExpectedRoi          pgtype.Numeric
}

func (q *Queries) GetOurEntryBidsByRunID(ctx context.Context, dollar_1 string) ([]GetOurEntryBidsByRunIDRow, error) {
	rows, err := q.db.Query(ctx, getOurEntryBidsByRunID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOurEntryBidsByRunIDRow
	for rows.Next() {
		var i GetOurEntryBidsByRunIDRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.RecommendedBidPoints,
			&i.ExpectedRoi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamPerformanceByID = `-- name: GetTeamPerformanceByID :one
WITH round_distribution AS (
    SELECT 
        st.team_id,
        CASE (st.wins + st.byes)
            WHEN 0 THEN 'R64'
            WHEN 1 THEN 'R64'
            WHEN 2 THEN 'R32'
            WHEN 3 THEN 'S16'
            WHEN 4 THEN 'E8'
            WHEN 5 THEN 'F4'
            WHEN 6 THEN 'Finals'
            WHEN 7 THEN 'Champion'
            ELSE 'Unknown'
        END as round_name,
        COUNT(*)::int as count
    FROM silver_simulated_tournaments st
    JOIN bronze_teams t ON t.id = st.team_id
    WHERE st.team_id = $1::bigint
    GROUP BY st.team_id, round_name
)
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    t.kenpom_net,
    COUNT(DISTINCT st.sim_id)::int as total_sims,
    AVG(st.wins)::float as avg_wins,
    AVG(CASE (st.wins + st.byes)
        WHEN 0 THEN 0
        WHEN 1 THEN 0
        WHEN 2 THEN 50
        WHEN 3 THEN 150
        WHEN 4 THEN 300
        WHEN 5 THEN 500
        WHEN 6 THEN 750
        WHEN 7 THEN 1050
        ELSE 0
    END)::float as avg_points,
    jsonb_object_agg(rd.round_name, rd.count) as round_distribution
FROM bronze_teams t
JOIN silver_simulated_tournaments st ON st.team_id = t.id
LEFT JOIN round_distribution rd ON rd.team_id = t.id
WHERE t.id = $1::bigint
GROUP BY t.id, t.school_name, t.seed, t.region, t.kenpom_net
`

type GetTeamPerformanceByIDRow struct {
	TeamID            int64
	SchoolName        string
	Seed              int32
	Region            string
	KenpomNet         pgtype.Numeric
	TotalSims         int32
	AvgWins           float64
	AvgPoints         float64
	RoundDistribution []byte
}

func (q *Queries) GetTeamPerformanceByID(ctx context.Context, dollar_1 int64) (GetTeamPerformanceByIDRow, error) {
	row := q.db.QueryRow(ctx, getTeamPerformanceByID, dollar_1)
	var i GetTeamPerformanceByIDRow
	err := row.Scan(
		&i.TeamID,
		&i.SchoolName,
		&i.Seed,
		&i.Region,
		&i.KenpomNet,
		&i.TotalSims,
		&i.AvgWins,
		&i.AvgPoints,
		&i.RoundDistribution,
	)
	return i, err
}

const getTeamPredictionsByYear = `-- name: GetTeamPredictionsByYear :many
SELECT 
    t.id as team_id,
    t.school_name,
    t.seed,
    t.region,
    t.kenpom_net
FROM bronze_teams t
JOIN bronze_tournaments bt ON bt.id = t.tournament_id
WHERE bt.season = $1::int
ORDER BY t.seed
`

type GetTeamPredictionsByYearRow struct {
	TeamID     int64
	SchoolName string
	Seed       int32
	Region     string
	KenpomNet  pgtype.Numeric
}

func (q *Queries) GetTeamPredictionsByYear(ctx context.Context, dollar_1 int32) ([]GetTeamPredictionsByYearRow, error) {
	rows, err := q.db.Query(ctx, getTeamPredictionsByYear, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamPredictionsByYearRow
	for rows.Next() {
		var i GetTeamPredictionsByYearRow
		if err := rows.Scan(
			&i.TeamID,
			&i.SchoolName,
			&i.Seed,
			&i.Region,
			&i.KenpomNet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentSimStatsByYear = `-- name: GetTournamentSimStatsByYear :one

SELECT 
    t.id as tournament_id,
    t.season,
    COUNT(DISTINCT st.sim_id)::int as n_sims,
    COUNT(DISTINCT st.team_id)::int as n_teams,
    AVG(st.wins + st.byes)::float as avg_progress,
    MAX(st.wins + st.byes)::int as max_progress
FROM bronze_tournaments t
JOIN silver_simulated_tournaments st ON t.id = st.tournament_id
WHERE t.season = $1::int
GROUP BY t.id, t.season
`

type GetTournamentSimStatsByYearRow struct {
	TournamentID int64
	Season       int32
	NSims        int32
	NTeams       int32
	AvgProgress  float64
	MaxProgress  int32
}

// ML Analytics Queries
// For tournament simulation and entry evaluation data
func (q *Queries) GetTournamentSimStatsByYear(ctx context.Context, dollar_1 int32) (GetTournamentSimStatsByYearRow, error) {
	row := q.db.QueryRow(ctx, getTournamentSimStatsByYear, dollar_1)
	var i GetTournamentSimStatsByYearRow
	err := row.Scan(
		&i.TournamentID,
		&i.Season,
		&i.NSims,
		&i.NTeams,
		&i.AvgProgress,
		&i.MaxProgress,
	)
	return i, err
}
