// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: calcutta_entries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEntryByID = `-- name: GetEntryByID :one
SELECT
    id,
    name,
    user_id,
    calcutta_id,
    created_at,
    updated_at,
    deleted_at
FROM core.entries
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetEntryByID(ctx context.Context, id string) (CoreEntry, error) {
	row := q.db.QueryRow(ctx, getEntryByID, id)
	var i CoreEntry
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.CalcuttaID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listEntriesByCalcuttaID = `-- name: ListEntriesByCalcuttaID :many
WITH entry_bids AS (
    SELECT
        cet.entry_id,
        ce.calcutta_id,
        cet.team_id,
        cet.bid_points::float8 AS bid_points,
        SUM(cet.bid_points::float8) OVER (
            PARTITION BY ce.calcutta_id, cet.team_id
        ) AS team_total_bid_points
    FROM core.entry_teams cet
    JOIN core.entries ce ON ce.id = cet.entry_id AND ce.deleted_at IS NULL
    WHERE cet.deleted_at IS NULL
),
entry_points AS (
    SELECT
        ce.id AS entry_id,
        COALESCE(
            SUM(
                CASE
                    WHEN eb.team_total_bid_points > 0 THEN
                        core.calcutta_points_for_progress(ce.calcutta_id, tt.wins, tt.byes)::float8
                        * (eb.bid_points / eb.team_total_bid_points)
                    ELSE 0
                END
            ),
            0
        )::float8 AS total_points
    FROM core.entries ce
    LEFT JOIN entry_bids eb ON eb.entry_id = ce.id AND eb.calcutta_id = ce.calcutta_id
    LEFT JOIN core.teams tt ON tt.id = eb.team_id AND tt.deleted_at IS NULL
    WHERE ce.deleted_at IS NULL
    GROUP BY ce.id, ce.calcutta_id
)
SELECT
    ce.id,
    ce.name,
    ce.user_id,
    ce.calcutta_id,
    ce.created_at,
    ce.updated_at,
    ce.deleted_at,
    COALESCE(ep.total_points, 0)::float8 AS total_points
FROM core.entries ce
LEFT JOIN entry_points ep ON ce.id = ep.entry_id
WHERE ce.calcutta_id = $1 AND ce.deleted_at IS NULL
ORDER BY ep.total_points DESC NULLS LAST, ce.created_at DESC
`

type ListEntriesByCalcuttaIDRow struct {
	ID          string
	Name        string
	UserID      pgtype.UUID
	CalcuttaID  string
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	TotalPoints float64
}

func (q *Queries) ListEntriesByCalcuttaID(ctx context.Context, calcuttaID string) ([]ListEntriesByCalcuttaIDRow, error) {
	rows, err := q.db.Query(ctx, listEntriesByCalcuttaID, calcuttaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEntriesByCalcuttaIDRow
	for rows.Next() {
		var i ListEntriesByCalcuttaIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.CalcuttaID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
