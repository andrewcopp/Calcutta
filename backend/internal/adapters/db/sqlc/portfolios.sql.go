// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: portfolios.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPortfolio = `-- name: CreatePortfolio :exec
INSERT INTO core.portfolios (id, name, user_id, pool_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
`

type CreatePortfolioParams struct {
	ID     string
	Name   string
	UserID pgtype.UUID
	PoolID string
}

func (q *Queries) CreatePortfolio(ctx context.Context, arg CreatePortfolioParams) error {
	_, err := q.db.Exec(ctx, createPortfolio,
		arg.ID,
		arg.Name,
		arg.UserID,
		arg.PoolID,
	)
	return err
}

const getPortfolioByID = `-- name: GetPortfolioByID :one
SELECT
    id,
    name,
    user_id,
    pool_id,
    status,
    created_at,
    updated_at,
    deleted_at
FROM core.portfolios
WHERE id = $1 AND deleted_at IS NULL
`

type GetPortfolioByIDRow struct {
	ID        string
	Name      string
	UserID    pgtype.UUID
	PoolID    string
	Status    string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
}

func (q *Queries) GetPortfolioByID(ctx context.Context, id string) (GetPortfolioByIDRow, error) {
	row := q.db.QueryRow(ctx, getPortfolioByID, id)
	var i GetPortfolioByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.PoolID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listDistinctUserIDsByPoolID = `-- name: ListDistinctUserIDsByPoolID :many
SELECT DISTINCT user_id
FROM core.portfolios
WHERE pool_id = $1 AND user_id IS NOT NULL AND deleted_at IS NULL
`

func (q *Queries) ListDistinctUserIDsByPoolID(ctx context.Context, poolID string) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, listDistinctUserIDsByPoolID, poolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var user_id pgtype.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPortfoliosByPoolID = `-- name: ListPortfoliosByPoolID :many
WITH portfolio_investments AS (
    SELECT
        inv.portfolio_id,
        p.pool_id,
        inv.team_id,
        inv.credits::float8 AS credits,
        SUM(inv.credits::float8) OVER (
            PARTITION BY p.pool_id, inv.team_id
        ) AS team_total_credits
    FROM core.investments inv
    JOIN core.portfolios p ON p.id = inv.portfolio_id AND p.deleted_at IS NULL
    WHERE inv.deleted_at IS NULL
),
portfolio_returns AS (
    SELECT
        p.id AS portfolio_id,
        COALESCE(
            SUM(
                CASE
                    WHEN pi.team_total_credits > 0 THEN
                        core.pool_returns_for_progress(p.pool_id, tt.wins, tt.byes)::float8
                        * (pi.credits / pi.team_total_credits)
                    ELSE 0
                END
            ),
            0
        )::float8 AS total_returns
    FROM core.portfolios p
    LEFT JOIN portfolio_investments pi ON pi.portfolio_id = p.id AND pi.pool_id = p.pool_id
    LEFT JOIN core.teams tt ON tt.id = pi.team_id AND tt.deleted_at IS NULL
    WHERE p.deleted_at IS NULL
    GROUP BY p.id, p.pool_id
)
SELECT
    p.id,
    p.name,
    p.user_id,
    p.pool_id,
    p.status,
    p.created_at,
    p.updated_at,
    p.deleted_at,
    COALESCE(pr.total_returns, 0)::float8 AS total_returns
FROM core.portfolios p
LEFT JOIN portfolio_returns pr ON p.id = pr.portfolio_id
WHERE p.pool_id = $1 AND p.deleted_at IS NULL
ORDER BY pr.total_returns DESC NULLS LAST, p.created_at DESC
`

type ListPortfoliosByPoolIDRow struct {
	ID           string
	Name         string
	UserID       pgtype.UUID
	PoolID       string
	Status       string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	DeletedAt    pgtype.Timestamptz
	TotalReturns float64
}

func (q *Queries) ListPortfoliosByPoolID(ctx context.Context, poolID string) ([]ListPortfoliosByPoolIDRow, error) {
	rows, err := q.db.Query(ctx, listPortfoliosByPoolID, poolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPortfoliosByPoolIDRow
	for rows.Next() {
		var i ListPortfoliosByPoolIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.PoolID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalReturns,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePortfolioStatus = `-- name: UpdatePortfolioStatus :exec
UPDATE core.portfolios
SET status = $2, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdatePortfolioStatusParams struct {
	ID     string
	Status string
}

func (q *Queries) UpdatePortfolioStatus(ctx context.Context, arg UpdatePortfolioStatusParams) error {
	_, err := q.db.Exec(ctx, updatePortfolioStatus, arg.ID, arg.Status)
	return err
}
