// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: investments.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInvestment = `-- name: CreateInvestment :exec
INSERT INTO core.investments (id, portfolio_id, team_id, credits, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateInvestmentParams struct {
	ID          string
	PortfolioID string
	TeamID      string
	Credits     int32
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
}

func (q *Queries) CreateInvestment(ctx context.Context, arg CreateInvestmentParams) error {
	_, err := q.db.Exec(ctx, createInvestment,
		arg.ID,
		arg.PortfolioID,
		arg.TeamID,
		arg.Credits,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const listInvestmentsByPortfolioID = `-- name: ListInvestmentsByPortfolioID :many
SELECT
    inv.id,
    inv.portfolio_id,
    inv.team_id,
    inv.credits,
    inv.created_at,
    inv.updated_at,
    inv.deleted_at,
    tt.id AS tournament_team_id,
    tt.school_id,
    tt.tournament_id,
    tt.seed,
    tt.region,
    tt.byes,
    tt.wins,
    tt.created_at AS team_created_at,
    tt.updated_at AS team_updated_at,
    tt.deleted_at AS team_deleted_at,
    s.name AS school_name
FROM core.investments inv
JOIN core.teams tt ON inv.team_id = tt.id
LEFT JOIN core.schools s ON tt.school_id = s.id
WHERE inv.portfolio_id = $1 AND inv.deleted_at IS NULL
ORDER BY inv.created_at DESC
`

type ListInvestmentsByPortfolioIDRow struct {
	ID               string
	PortfolioID      string
	TeamID           string
	Credits          int32
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	DeletedAt        pgtype.Timestamptz
	TournamentTeamID string
	SchoolID         string
	TournamentID     string
	Seed             int32
	Region           string
	Byes             int32
	Wins             int32
	TeamCreatedAt    pgtype.Timestamptz
	TeamUpdatedAt    pgtype.Timestamptz
	TeamDeletedAt    pgtype.Timestamptz
	SchoolName       *string
}

func (q *Queries) ListInvestmentsByPortfolioID(ctx context.Context, portfolioID string) ([]ListInvestmentsByPortfolioIDRow, error) {
	rows, err := q.db.Query(ctx, listInvestmentsByPortfolioID, portfolioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInvestmentsByPortfolioIDRow
	for rows.Next() {
		var i ListInvestmentsByPortfolioIDRow
		if err := rows.Scan(
			&i.ID,
			&i.PortfolioID,
			&i.TeamID,
			&i.Credits,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TournamentTeamID,
			&i.SchoolID,
			&i.TournamentID,
			&i.Seed,
			&i.Region,
			&i.Byes,
			&i.Wins,
			&i.TeamCreatedAt,
			&i.TeamUpdatedAt,
			&i.TeamDeletedAt,
			&i.SchoolName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvestmentsByPortfolioIDs = `-- name: ListInvestmentsByPortfolioIDs :many
SELECT
    inv.id,
    inv.portfolio_id,
    inv.team_id,
    inv.credits,
    inv.created_at,
    inv.updated_at,
    inv.deleted_at,
    tt.id AS tournament_team_id,
    tt.school_id,
    tt.tournament_id,
    tt.seed,
    tt.region,
    tt.byes,
    tt.wins,
    tt.created_at AS team_created_at,
    tt.updated_at AS team_updated_at,
    tt.deleted_at AS team_deleted_at,
    s.name AS school_name
FROM core.investments inv
JOIN core.teams tt ON inv.team_id = tt.id
LEFT JOIN core.schools s ON tt.school_id = s.id
WHERE inv.portfolio_id = ANY($1::uuid[]) AND inv.deleted_at IS NULL
ORDER BY inv.created_at DESC
`

type ListInvestmentsByPortfolioIDsRow struct {
	ID               string
	PortfolioID      string
	TeamID           string
	Credits          int32
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	DeletedAt        pgtype.Timestamptz
	TournamentTeamID string
	SchoolID         string
	TournamentID     string
	Seed             int32
	Region           string
	Byes             int32
	Wins             int32
	TeamCreatedAt    pgtype.Timestamptz
	TeamUpdatedAt    pgtype.Timestamptz
	TeamDeletedAt    pgtype.Timestamptz
	SchoolName       *string
}

func (q *Queries) ListInvestmentsByPortfolioIDs(ctx context.Context, portfolioIds []string) ([]ListInvestmentsByPortfolioIDsRow, error) {
	rows, err := q.db.Query(ctx, listInvestmentsByPortfolioIDs, portfolioIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInvestmentsByPortfolioIDsRow
	for rows.Next() {
		var i ListInvestmentsByPortfolioIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.PortfolioID,
			&i.TeamID,
			&i.Credits,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TournamentTeamID,
			&i.SchoolID,
			&i.TournamentID,
			&i.Seed,
			&i.Region,
			&i.Byes,
			&i.Wins,
			&i.TeamCreatedAt,
			&i.TeamUpdatedAt,
			&i.TeamDeletedAt,
			&i.SchoolName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteInvestmentsByPortfolioID = `-- name: SoftDeleteInvestmentsByPortfolioID :execrows
UPDATE core.investments
SET deleted_at = $1,
    updated_at = $1
WHERE portfolio_id = $2 AND deleted_at IS NULL
`

type SoftDeleteInvestmentsByPortfolioIDParams struct {
	DeletedAt   pgtype.Timestamptz
	PortfolioID string
}

func (q *Queries) SoftDeleteInvestmentsByPortfolioID(ctx context.Context, arg SoftDeleteInvestmentsByPortfolioIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteInvestmentsByPortfolioID, arg.DeletedAt, arg.PortfolioID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
