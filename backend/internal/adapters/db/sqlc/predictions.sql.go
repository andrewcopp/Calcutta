// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: predictions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreatePredictedTeamValuesParams struct {
	PredictionBatchID    string
	TournamentID         string
	TeamID               string
	ActualPoints         *float64
	ExpectedPoints       float64
	VariancePoints       *float64
	StdPoints            *float64
	PRound1              *float64
	PRound2              *float64
	PRound3              *float64
	PRound4              *float64
	PRound5              *float64
	PRound6              *float64
	PRound7              *float64
	FavoritesTotalPoints *float64
}

const createPredictedTeamValue = `-- name: CreatePredictedTeamValue :exec
INSERT INTO compute.predicted_team_values (
    prediction_batch_id,
    tournament_id,
    team_id,
    actual_points,
    expected_points,
    variance_points,
    std_points,
    p_round_1,
    p_round_2,
    p_round_3,
    p_round_4,
    p_round_5,
    p_round_6,
    p_round_7,
    favorites_total_points
)
VALUES (
    $1::uuid,
    $2::uuid,
    $3::uuid,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15
)
`

type CreatePredictedTeamValueParams struct {
	PredictionBatchID    string
	TournamentID         string
	TeamID               string
	ActualPoints         *float64
	ExpectedPoints       float64
	VariancePoints       *float64
	StdPoints            *float64
	PRound1              *float64
	PRound2              *float64
	PRound3              *float64
	PRound4              *float64
	PRound5              *float64
	PRound6              *float64
	PRound7              *float64
	FavoritesTotalPoints *float64
}

func (q *Queries) CreatePredictedTeamValue(ctx context.Context, arg CreatePredictedTeamValueParams) error {
	_, err := q.db.Exec(ctx, createPredictedTeamValue,
		arg.PredictionBatchID,
		arg.TournamentID,
		arg.TeamID,
		arg.ActualPoints,
		arg.ExpectedPoints,
		arg.VariancePoints,
		arg.StdPoints,
		arg.PRound1,
		arg.PRound2,
		arg.PRound3,
		arg.PRound4,
		arg.PRound5,
		arg.PRound6,
		arg.PRound7,
		arg.FavoritesTotalPoints,
	)
	return err
}

const createPredictionBatch = `-- name: CreatePredictionBatch :one
INSERT INTO compute.prediction_batches (
    tournament_id,
    probability_source_key,
    game_outcome_spec_json,
    through_round
)
VALUES ($1::uuid, $2, $3::jsonb, $4)
RETURNING id::text
`

type CreatePredictionBatchParams struct {
	TournamentID         string
	ProbabilitySourceKey string
	GameOutcomeSpecJson  []byte
	ThroughRound         int32
}

func (q *Queries) CreatePredictionBatch(ctx context.Context, arg CreatePredictionBatchParams) (string, error) {
	row := q.db.QueryRow(ctx, createPredictionBatch,
		arg.TournamentID,
		arg.ProbabilitySourceKey,
		arg.GameOutcomeSpecJson,
		arg.ThroughRound,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getFinalFourConfig = `-- name: GetFinalFourConfig :one
SELECT final_four_top_left, final_four_bottom_left,
       final_four_top_right, final_four_bottom_right
FROM core.tournaments
WHERE id = $1::uuid AND deleted_at IS NULL
`

type GetFinalFourConfigRow struct {
	FinalFourTopLeft     *string
	FinalFourBottomLeft  *string
	FinalFourTopRight    *string
	FinalFourBottomRight *string
}

func (q *Queries) GetFinalFourConfig(ctx context.Context, dollar_1 string) (GetFinalFourConfigRow, error) {
	row := q.db.QueryRow(ctx, getFinalFourConfig, dollar_1)
	var i GetFinalFourConfigRow
	err := row.Scan(
		&i.FinalFourTopLeft,
		&i.FinalFourBottomLeft,
		&i.FinalFourTopRight,
		&i.FinalFourBottomRight,
	)
	return i, err
}

const getLatestPredictionBatch = `-- name: GetLatestPredictionBatch :one
SELECT id::text, probability_source_key, through_round, created_at
FROM compute.prediction_batches
WHERE tournament_id = $1::uuid
    AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestPredictionBatchRow struct {
	ID                   string
	ProbabilitySourceKey string
	ThroughRound         int32
	CreatedAt            pgtype.Timestamptz
}

func (q *Queries) GetLatestPredictionBatch(ctx context.Context, dollar_1 string) (GetLatestPredictionBatchRow, error) {
	row := q.db.QueryRow(ctx, getLatestPredictionBatch, dollar_1)
	var i GetLatestPredictionBatchRow
	err := row.Scan(
		&i.ID,
		&i.ProbabilitySourceKey,
		&i.ThroughRound,
		&i.CreatedAt,
	)
	return i, err
}

const getPredictedTeamValues = `-- name: GetPredictedTeamValues :many
SELECT
    team_id::text,
    COALESCE(actual_points, 0) AS actual_points,
    expected_points,
    COALESCE(variance_points, 0) AS variance_points,
    COALESCE(std_points, 0) AS std_points,
    COALESCE(p_round_1, 0) AS p_round_1,
    COALESCE(p_round_2, 0) AS p_round_2,
    COALESCE(p_round_3, 0) AS p_round_3,
    COALESCE(p_round_4, 0) AS p_round_4,
    COALESCE(p_round_5, 0) AS p_round_5,
    COALESCE(p_round_6, 0) AS p_round_6,
    COALESCE(p_round_7, 0) AS p_round_7,
    COALESCE(favorites_total_points, 0) AS favorites_total_points
FROM compute.predicted_team_values
WHERE prediction_batch_id = $1::uuid
    AND deleted_at IS NULL
`

type GetPredictedTeamValuesRow struct {
	TeamID               string
	ActualPoints         float64
	ExpectedPoints       float64
	VariancePoints       float64
	StdPoints            float64
	PRound1              float64
	PRound2              float64
	PRound3              float64
	PRound4              float64
	PRound5              float64
	PRound6              float64
	PRound7              float64
	FavoritesTotalPoints float64
}

func (q *Queries) GetPredictedTeamValues(ctx context.Context, dollar_1 string) ([]GetPredictedTeamValuesRow, error) {
	rows, err := q.db.Query(ctx, getPredictedTeamValues, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPredictedTeamValuesRow
	for rows.Next() {
		var i GetPredictedTeamValuesRow
		if err := rows.Scan(
			&i.TeamID,
			&i.ActualPoints,
			&i.ExpectedPoints,
			&i.VariancePoints,
			&i.StdPoints,
			&i.PRound1,
			&i.PRound2,
			&i.PRound3,
			&i.PRound4,
			&i.PRound5,
			&i.PRound6,
			&i.PRound7,
			&i.FavoritesTotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPredictionBatchByID = `-- name: GetPredictionBatchByID :one
SELECT id::text, probability_source_key, through_round, created_at
FROM compute.prediction_batches
WHERE id = $1::uuid
    AND deleted_at IS NULL
`

type GetPredictionBatchByIDRow struct {
	ID                   string
	ProbabilitySourceKey string
	ThroughRound         int32
	CreatedAt            pgtype.Timestamptz
}

func (q *Queries) GetPredictionBatchByID(ctx context.Context, dollar_1 string) (GetPredictionBatchByIDRow, error) {
	row := q.db.QueryRow(ctx, getPredictionBatchByID, dollar_1)
	var i GetPredictionBatchByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProbabilitySourceKey,
		&i.ThroughRound,
		&i.CreatedAt,
	)
	return i, err
}

const getScoringRulesForTournament = `-- name: GetScoringRulesForTournament :many
SELECT psr.win_index::int, psr.points_awarded::int
FROM core.pool_scoring_rules psr
JOIN core.pools p ON p.id = psr.pool_id AND p.deleted_at IS NULL
WHERE p.tournament_id = $1::uuid
    AND psr.deleted_at IS NULL
ORDER BY psr.win_index ASC
LIMIT 10
`

type GetScoringRulesForTournamentRow struct {
	PsrWinIndex      int32
	PsrPointsAwarded int32
}

func (q *Queries) GetScoringRulesForTournament(ctx context.Context, dollar_1 string) ([]GetScoringRulesForTournamentRow, error) {
	rows, err := q.db.Query(ctx, getScoringRulesForTournament, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoringRulesForTournamentRow
	for rows.Next() {
		var i GetScoringRulesForTournamentRow
		if err := rows.Scan(&i.PsrWinIndex, &i.PsrPointsAwarded); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsWithKenpomForPrediction = `-- name: GetTeamsWithKenpomForPrediction :many
SELECT
    t.id::text,
    t.seed,
    t.region,
    COALESCE(ks.net_rtg, 0) AS kenpom_net,
    t.wins,
    COALESCE(t.byes, 0) AS byes
FROM core.teams t
LEFT JOIN core.team_kenpom_stats ks
    ON ks.team_id = t.id
    AND ks.deleted_at IS NULL
WHERE t.tournament_id = $1::uuid
    AND t.deleted_at IS NULL
ORDER BY t.region, t.seed
`

type GetTeamsWithKenpomForPredictionRow struct {
	TID       string
	Seed      int32
	Region    string
	KenpomNet float64
	Wins      int32
	Byes      int32
}

func (q *Queries) GetTeamsWithKenpomForPrediction(ctx context.Context, dollar_1 string) ([]GetTeamsWithKenpomForPredictionRow, error) {
	rows, err := q.db.Query(ctx, getTeamsWithKenpomForPrediction, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsWithKenpomForPredictionRow
	for rows.Next() {
		var i GetTeamsWithKenpomForPredictionRow
		if err := rows.Scan(
			&i.TID,
			&i.Seed,
			&i.Region,
			&i.KenpomNet,
			&i.Wins,
			&i.Byes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEligibleTournamentsForBackfill = `-- name: ListEligibleTournamentsForBackfill :many
SELECT t.id::text
FROM core.tournaments t
WHERE t.deleted_at IS NULL
    AND NOT EXISTS (
        SELECT 1 FROM compute.prediction_batches pb
        WHERE pb.tournament_id = t.id AND pb.deleted_at IS NULL
    )
    AND (
        SELECT COUNT(*) FROM core.teams tt
        WHERE tt.tournament_id = t.id AND tt.deleted_at IS NULL
    ) = 68
    AND EXISTS (
        SELECT 1 FROM core.team_kenpom_stats ks
        JOIN core.teams tt ON tt.id = ks.team_id AND tt.deleted_at IS NULL
        WHERE tt.tournament_id = t.id AND ks.deleted_at IS NULL
    )
    AND EXISTS (
        SELECT 1 FROM core.pool_scoring_rules psr
        JOIN core.pools p ON p.id = psr.pool_id AND p.deleted_at IS NULL
        WHERE p.tournament_id = t.id AND psr.deleted_at IS NULL
    )
`

func (q *Queries) ListEligibleTournamentsForBackfill(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listEligibleTournamentsForBackfill)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var t_id string
		if err := rows.Scan(&t_id); err != nil {
			return nil, err
		}
		items = append(items, t_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPredictionBatches = `-- name: ListPredictionBatches :many
SELECT id::text, probability_source_key, through_round, created_at
FROM compute.prediction_batches
WHERE tournament_id = $1::uuid
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListPredictionBatchesRow struct {
	ID                   string
	ProbabilitySourceKey string
	ThroughRound         int32
	CreatedAt            pgtype.Timestamptz
}

func (q *Queries) ListPredictionBatches(ctx context.Context, dollar_1 string) ([]ListPredictionBatchesRow, error) {
	rows, err := q.db.Query(ctx, listPredictionBatches, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPredictionBatchesRow
	for rows.Next() {
		var i ListPredictionBatchesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProbabilitySourceKey,
			&i.ThroughRound,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pruneOldBatchesForCheckpoint = `-- name: PruneOldBatchesForCheckpoint :execrows
DELETE FROM compute.prediction_batches pb_outer
WHERE pb_outer.tournament_id = $1::uuid
    AND pb_outer.through_round = $2
    AND pb_outer.deleted_at IS NULL
    AND pb_outer.id NOT IN (
        SELECT pb_inner.id FROM compute.prediction_batches pb_inner
        WHERE pb_inner.tournament_id = $1::uuid
            AND pb_inner.through_round = $2
            AND pb_inner.deleted_at IS NULL
        ORDER BY pb_inner.created_at DESC
        LIMIT $3
    )
`

type PruneOldBatchesForCheckpointParams struct {
	TournamentID string
	ThroughRound int32
	KeepN        int32
}

func (q *Queries) PruneOldBatchesForCheckpoint(ctx context.Context, arg PruneOldBatchesForCheckpointParams) (int64, error) {
	result, err := q.db.Exec(ctx, pruneOldBatchesForCheckpoint, arg.TournamentID, arg.ThroughRound, arg.KeepN)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
