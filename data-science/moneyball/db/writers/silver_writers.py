"""
Silver layer database writers.

Write ML predictions, simulations, and enriched data using UUIDs.
"""
import logging
import pandas as pd
import psycopg2.extras
from typing import Dict
from moneyball.db.connection import get_db_connection

logger = logging.getLogger(__name__)


def write_predicted_game_outcomes(
    tournament_id: str,
    predictions_df: pd.DataFrame,
    team_id_map: Dict[str, str],
    model_version: str = None
) -> int:
    """
    Write game outcome predictions.

    Args:
        tournament_id: Tournament ID
        predictions_df: DataFrame with columns:
            - game_id, round, team1_key, team2_key
            - p_team1_wins_given_matchup, p_matchup
        team_id_map: Dict mapping school_slug to team_id
        model_version: Optional model version

    Returns:
        Number of rows inserted
    """
    with get_db_connection() as conn:
        with conn.cursor() as cur:
            # Clear existing predictions
            cur.execute("""
                DELETE FROM derived.predicted_game_outcomes
                WHERE tournament_id = %s
            """, (tournament_id,))

            # Predictions already have team1_id and team2_id
            df = predictions_df.copy()

            # Map round names to inverted integers (championship = 0)
            round_mapping = {
                'championship': 0,
                'final_four': 1,
                'elite_8': 2,
                'sweet_16': 3,
                'round_of_32': 4,
                'round_of_64': 5,
                'first_four': 6,
            }

            # Use round_int if provided, otherwise map from round name
            if 'round_int' not in df.columns:
                df['round_int'] = df['round'].map(round_mapping)
            else:
                # Invert the round_int (our data has 1=R1, but DB wants 5=R1)
                df['round_int'] = df['round'].map(round_mapping)

            values = [
                (
                    tournament_id,
                    row['game_id'],
                    int(row['round_int']),
                    str(row['team1_id']),  # team_id is UUID string
                    str(row['team2_id']),  # team_id is UUID string
                    float(row.get('p_team1_wins_given_matchup',
                          row.get('p_team1_wins', 0.5))),
                    float(row.get('p_matchup', 1.0)),
                    model_version
                )
                for _, row in df.iterrows()
            ]

            psycopg2.extras.execute_batch(cur, """
                INSERT INTO derived.predicted_game_outcomes
                (tournament_id, game_id, round, team1_id, team2_id,
                 p_team1_wins, p_matchup, model_version)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """, values)

            conn.commit()
            return len(values)


def write_simulated_tournaments(
    tournament_id: str,
    simulations_df: pd.DataFrame,
    team_id_map: Dict[str, str]
) -> int:
    """
    Write simulated tournament outcomes to derived schema.

    Simulated tournaments are derived data (Monte Carlo simulations).
    The tournament_id passed here is now expected to be a core.tournaments id.

    Args:
        tournament_id: Core tournament UUID
        simulations_df: DataFrame with columns:
            - sim_id, school_slug, wins, byes, eliminated
        team_id_map: Dict mapping school_slug to team_id

    Returns:
        Number of rows inserted
    """
    with get_db_connection() as conn:
        with conn.cursor() as cur:
            # tournament_id is already a core tournament id.
            core_tournament_id = tournament_id

            # Create simulation state snapshot from current core tournament state.
            cur.execute("""
                INSERT INTO derived.simulation_states (tournament_id, source, description)
                VALUES (%s, 'moneyball_pipeline', 'Autogenerated snapshot for tournament simulation batch')
                RETURNING id
            """, (core_tournament_id,))
            snapshot_id = str(cur.fetchone()[0])

            cur.execute("""
                INSERT INTO derived.simulation_state_teams (
                    simulation_state_id,
                    team_id,
                    wins,
                    byes,
                    eliminated
                )
                SELECT
                    %s,
                    ct.id,
                    ct.wins,
                    ct.byes,
                    ct.eliminated
                FROM core.teams ct
                WHERE ct.tournament_id = %s
                  AND ct.deleted_at IS NULL
                ON CONFLICT (simulation_state_id, team_id) DO NOTHING
            """, (snapshot_id, core_tournament_id))

            # Create simulated_tournament record.
            n_sims = int(simulations_df['sim_id'].nunique())
            cur.execute("""
                INSERT INTO derived.simulated_tournaments (
                    tournament_id,
                    simulation_state_id,
                    n_sims,
                    seed,
                    probability_source_key
                )
                VALUES (%s, %s, %s, %s, %s)
                RETURNING id
            """, (core_tournament_id, snapshot_id, n_sims, 42, 'moneyball_pipeline'))
            batch_id = str(cur.fetchone()[0])

            # Backward-compat cleanup: clear legacy rows (no batch id) for this tournament.
            cur.execute("""
                DELETE FROM derived.simulated_teams
                WHERE tournament_id = %s
                  AND simulated_tournament_id IS NULL
            """, (tournament_id,))

            # Map school_slug to team_id
            df = simulations_df.copy()
            df['team_id'] = df['school_slug'].map(team_id_map)

            # Check for unmapped teams
            if df['team_id'].isna().any():
                unmapped = df[df['team_id'].isna()]['school_slug'].unique()
                raise ValueError(f"Unmapped teams: {list(unmapped)}")

            # Prepare values
            values = [
                (
                    batch_id,
                    tournament_id,
                    int(row['sim_id']),
                    str(row['team_id']),  # team_id is UUID string
                    int(row['wins']),
                    int(row['byes']),
                    bool(row['eliminated'])
                )
                for _, row in df.iterrows()
            ]

            # Batch insert
            psycopg2.extras.execute_batch(cur, """
                INSERT INTO derived.simulated_teams
                (simulated_tournament_id, tournament_id, sim_id, team_id, wins, byes, eliminated)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, values, page_size=10000)

            conn.commit()
            return len(values)


